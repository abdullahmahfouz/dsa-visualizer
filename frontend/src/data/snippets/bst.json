{
  "python": "class TreeNode:\n    \"\"\"Node in a Binary Search Tree\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BST:\n    \"\"\"Binary Search Tree - Left < Root < Right\"\"\"\n    \n    def __init__(self):\n        self.root = None\n    \n    def insert(self, key):\n        \"\"\"Insert maintaining BST property - O(log n) avg\"\"\"\n        if not self.root:\n            self.root = TreeNode(key)\n            return\n        self._insert_rec(self.root, key)\n    \n    def _insert_rec(self, node, key):\n        if key < node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_rec(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_rec(node.right, key)\n    \n    def search(self, key):\n        \"\"\"Search for key - O(log n) avg\"\"\"\n        return self._search_rec(self.root, key)\n    \n    def _search_rec(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search_rec(node.left, key)\n        return self._search_rec(node.right, key)\n    \n    def delete(self, key):\n        \"\"\"Delete node with key - O(log n) avg\"\"\"\n        self.root = self._delete_rec(self.root, key)\n    \n    def _delete_rec(self, node, key):\n        if node is None:\n            return node\n        \n        if key < node.key:\n            node.left = self._delete_rec(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_rec(node.right, key)\n        else:\n            # Node found - handle 3 cases\n            # Case 1 & 2: No child or one child\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            # Case 3: Two children - get inorder successor\n            successor = self._min_value(node.right)\n            node.key = successor.key\n            node.right = self._delete_rec(node.right, successor.key)\n        return node\n    \n    def _min_value(self, node):\n        \"\"\"Find minimum value node (leftmost)\"\"\"\n        current = node\n        while current.left:\n            current = current.left\n        return current\n    \n    def inorder(self):\n        \"\"\"Inorder traversal - returns sorted order!\"\"\"\n        result = []\n        self._inorder_rec(self.root, result)\n        return result\n    \n    def _inorder_rec(self, node, result):\n        if node:\n            self._inorder_rec(node.left, result)\n            result.append(node.key)\n            self._inorder_rec(node.right, result)\n\n# Usage\nbst = BST()\nfor val in [50, 30, 70, 20, 40, 60, 80]:\n    bst.insert(val)\n\nprint(\"Inorder (sorted):\", bst.inorder())  # [20, 30, 40, 50, 60, 70, 80]\nprint(\"Search 40:\", bst.search(40) is not None)  # True\nbst.delete(30)  # Delete node with two children\nprint(\"After delete 30:\", bst.inorder())  # [20, 40, 50, 60, 70, 80]",

  "javascript": "class TreeNode {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BST {\n    // Binary Search Tree - Left < Root < Right\n    \n    constructor() {\n        this.root = null;\n    }\n    \n    insert(key) {\n        // Insert maintaining BST property - O(log n) avg\n        if (!this.root) {\n            this.root = new TreeNode(key);\n            return;\n        }\n        this._insertRec(this.root, key);\n    }\n    \n    _insertRec(node, key) {\n        if (key < node.key) {\n            if (!node.left) {\n                node.left = new TreeNode(key);\n            } else {\n                this._insertRec(node.left, key);\n            }\n        } else {\n            if (!node.right) {\n                node.right = new TreeNode(key);\n            } else {\n                this._insertRec(node.right, key);\n            }\n        }\n    }\n    \n    search(key) {\n        // Search for key - O(log n) avg\n        return this._searchRec(this.root, key);\n    }\n    \n    _searchRec(node, key) {\n        if (!node || node.key === key) return node;\n        if (key < node.key) return this._searchRec(node.left, key);\n        return this._searchRec(node.right, key);\n    }\n    \n    delete(key) {\n        // Delete node with key - O(log n) avg\n        this.root = this._deleteRec(this.root, key);\n    }\n    \n    _deleteRec(node, key) {\n        if (!node) return node;\n        \n        if (key < node.key) {\n            node.left = this._deleteRec(node.left, key);\n        } else if (key > node.key) {\n            node.right = this._deleteRec(node.right, key);\n        } else {\n            // Node found - handle 3 cases\n            if (!node.left) return node.right;\n            if (!node.right) return node.left;\n            // Two children - get inorder successor\n            const successor = this._minValue(node.right);\n            node.key = successor.key;\n            node.right = this._deleteRec(node.right, successor.key);\n        }\n        return node;\n    }\n    \n    _minValue(node) {\n        // Find minimum value node (leftmost)\n        let current = node;\n        while (current.left) current = current.left;\n        return current;\n    }\n    \n    inorder() {\n        // Inorder traversal - returns sorted order!\n        const result = [];\n        this._inorderRec(this.root, result);\n        return result;\n    }\n    \n    _inorderRec(node, result) {\n        if (node) {\n            this._inorderRec(node.left, result);\n            result.push(node.key);\n            this._inorderRec(node.right, result);\n        }\n    }\n}\n\n// Usage\nconst bst = new BST();\n[50, 30, 70, 20, 40, 60, 80].forEach(val => bst.insert(val));\n\nconsole.log(\"Inorder (sorted):\", bst.inorder());  // [20, 30, 40, 50, 60, 70, 80]\nconsole.log(\"Search 40:\", bst.search(40) !== null);  // true\nbst.delete(30);  // Delete node with two children\nconsole.log(\"After delete 30:\", bst.inorder());  // [20, 40, 50, 60, 70, 80]",

  "java": "import java.util.*;\n\nclass TreeNode {\n    int key;\n    TreeNode left, right;\n    \n    TreeNode(int key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n}\n\npublic class BST {\n    // Binary Search Tree - Left < Root < Right\n    private TreeNode root;\n    \n    public BST() {\n        this.root = null;\n    }\n    \n    public void insert(int key) {\n        // Insert maintaining BST property - O(log n) avg\n        if (root == null) {\n            root = new TreeNode(key);\n            return;\n        }\n        insertRec(root, key);\n    }\n    \n    private void insertRec(TreeNode node, int key) {\n        if (key < node.key) {\n            if (node.left == null) node.left = new TreeNode(key);\n            else insertRec(node.left, key);\n        } else {\n            if (node.right == null) node.right = new TreeNode(key);\n            else insertRec(node.right, key);\n        }\n    }\n    \n    public TreeNode search(int key) {\n        // Search for key - O(log n) avg\n        return searchRec(root, key);\n    }\n    \n    private TreeNode searchRec(TreeNode node, int key) {\n        if (node == null || node.key == key) return node;\n        if (key < node.key) return searchRec(node.left, key);\n        return searchRec(node.right, key);\n    }\n    \n    public void delete(int key) {\n        // Delete node with key - O(log n) avg\n        root = deleteRec(root, key);\n    }\n    \n    private TreeNode deleteRec(TreeNode node, int key) {\n        if (node == null) return node;\n        \n        if (key < node.key) {\n            node.left = deleteRec(node.left, key);\n        } else if (key > node.key) {\n            node.right = deleteRec(node.right, key);\n        } else {\n            // Node found - handle 3 cases\n            if (node.left == null) return node.right;\n            if (node.right == null) return node.left;\n            // Two children - get inorder successor\n            TreeNode successor = minValue(node.right);\n            node.key = successor.key;\n            node.right = deleteRec(node.right, successor.key);\n        }\n        return node;\n    }\n    \n    private TreeNode minValue(TreeNode node) {\n        // Find minimum value node (leftmost)\n        TreeNode current = node;\n        while (current.left != null) current = current.left;\n        return current;\n    }\n    \n    public List<Integer> inorder() {\n        // Inorder traversal - returns sorted order!\n        List<Integer> result = new ArrayList<>();\n        inorderRec(root, result);\n        return result;\n    }\n    \n    private void inorderRec(TreeNode node, List<Integer> result) {\n        if (node != null) {\n            inorderRec(node.left, result);\n            result.add(node.key);\n            inorderRec(node.right, result);\n        }\n    }\n}\n\n// Usage\nBST bst = new BST();\nfor (int val : new int[]{50, 30, 70, 20, 40, 60, 80}) bst.insert(val);\n\nSystem.out.println(\"Inorder: \" + bst.inorder());  // [20, 30, 40, 50, 60, 70, 80]\nSystem.out.println(\"Search 40: \" + (bst.search(40) != null));  // true\nbst.delete(30);  // Delete node with two children\nSystem.out.println(\"After delete: \" + bst.inorder());  // [20, 40, 50, 60, 70, 80]",

  "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int key;\n    TreeNode *left, *right;\n    TreeNode(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n\nclass BST {\n    // Binary Search Tree - Left < Root < Right\nprivate:\n    TreeNode* root;\n    \n    void insertRec(TreeNode* node, int key) {\n        if (key < node->key) {\n            if (!node->left) node->left = new TreeNode(key);\n            else insertRec(node->left, key);\n        } else {\n            if (!node->right) node->right = new TreeNode(key);\n            else insertRec(node->right, key);\n        }\n    }\n    \n    TreeNode* searchRec(TreeNode* node, int key) {\n        if (!node || node->key == key) return node;\n        if (key < node->key) return searchRec(node->left, key);\n        return searchRec(node->right, key);\n    }\n    \n    TreeNode* minValue(TreeNode* node) {\n        TreeNode* current = node;\n        while (current->left) current = current->left;\n        return current;\n    }\n    \n    TreeNode* deleteRec(TreeNode* node, int key) {\n        if (!node) return node;\n        \n        if (key < node->key) {\n            node->left = deleteRec(node->left, key);\n        } else if (key > node->key) {\n            node->right = deleteRec(node->right, key);\n        } else {\n            // Node found - handle 3 cases\n            if (!node->left) return node->right;\n            if (!node->right) return node->left;\n            // Two children - get inorder successor\n            TreeNode* successor = minValue(node->right);\n            node->key = successor->key;\n            node->right = deleteRec(node->right, successor->key);\n        }\n        return node;\n    }\n    \n    void inorderRec(TreeNode* node, vector<int>& result) {\n        if (node) {\n            inorderRec(node->left, result);\n            result.push_back(node->key);\n            inorderRec(node->right, result);\n        }\n    }\n\npublic:\n    BST() : root(nullptr) {}\n    \n    void insert(int key) {\n        // Insert maintaining BST property - O(log n) avg\n        if (!root) { root = new TreeNode(key); return; }\n        insertRec(root, key);\n    }\n    \n    TreeNode* search(int key) {\n        // Search for key - O(log n) avg\n        return searchRec(root, key);\n    }\n    \n    void remove(int key) {\n        // Delete node with key - O(log n) avg\n        root = deleteRec(root, key);\n    }\n    \n    vector<int> inorder() {\n        // Inorder traversal - returns sorted order!\n        vector<int> result;\n        inorderRec(root, result);\n        return result;\n    }\n};\n\n// Usage\nint main() {\n    BST bst;\n    for (int val : {50, 30, 70, 20, 40, 60, 80}) bst.insert(val);\n    \n    // Inorder (sorted): [20, 30, 40, 50, 60, 70, 80]\n    // Search 40: true\n    bst.remove(30);  // Delete node with two children\n    // After delete: [20, 40, 50, 60, 70, 80]\n    return 0;\n}",

  "c#": "using System;\nusing System.Collections.Generic;\n\npublic class TreeNode\n{\n    public int Key { get; set; }\n    public TreeNode Left { get; set; }\n    public TreeNode Right { get; set; }\n    \n    public TreeNode(int key)\n    {\n        Key = key;\n        Left = null;\n        Right = null;\n    }\n}\n\npublic class BST\n{\n    // Binary Search Tree - Left < Root < Right\n    private TreeNode root;\n    \n    public BST() { root = null; }\n    \n    public void Insert(int key)\n    {\n        // Insert maintaining BST property - O(log n) avg\n        if (root == null) { root = new TreeNode(key); return; }\n        InsertRec(root, key);\n    }\n    \n    private void InsertRec(TreeNode node, int key)\n    {\n        if (key < node.Key)\n        {\n            if (node.Left == null) node.Left = new TreeNode(key);\n            else InsertRec(node.Left, key);\n        }\n        else\n        {\n            if (node.Right == null) node.Right = new TreeNode(key);\n            else InsertRec(node.Right, key);\n        }\n    }\n    \n    public TreeNode Search(int key)\n    {\n        // Search for key - O(log n) avg\n        return SearchRec(root, key);\n    }\n    \n    private TreeNode SearchRec(TreeNode node, int key)\n    {\n        if (node == null || node.Key == key) return node;\n        if (key < node.Key) return SearchRec(node.Left, key);\n        return SearchRec(node.Right, key);\n    }\n    \n    public void Delete(int key)\n    {\n        // Delete node with key - O(log n) avg\n        root = DeleteRec(root, key);\n    }\n    \n    private TreeNode DeleteRec(TreeNode node, int key)\n    {\n        if (node == null) return node;\n        \n        if (key < node.Key)\n            node.Left = DeleteRec(node.Left, key);\n        else if (key > node.Key)\n            node.Right = DeleteRec(node.Right, key);\n        else\n        {\n            // Node found - handle 3 cases\n            if (node.Left == null) return node.Right;\n            if (node.Right == null) return node.Left;\n            // Two children - get inorder successor\n            var successor = MinValue(node.Right);\n            node.Key = successor.Key;\n            node.Right = DeleteRec(node.Right, successor.Key);\n        }\n        return node;\n    }\n    \n    private TreeNode MinValue(TreeNode node)\n    {\n        var current = node;\n        while (current.Left != null) current = current.Left;\n        return current;\n    }\n    \n    public List<int> Inorder()\n    {\n        // Inorder traversal - returns sorted order!\n        var result = new List<int>();\n        InorderRec(root, result);\n        return result;\n    }\n    \n    private void InorderRec(TreeNode node, List<int> result)\n    {\n        if (node != null)\n        {\n            InorderRec(node.Left, result);\n            result.Add(node.Key);\n            InorderRec(node.Right, result);\n        }\n    }\n}\n\n// Usage\nvar bst = new BST();\nforeach (var val in new[] {50, 30, 70, 20, 40, 60, 80}) bst.Insert(val);\n\nConsole.WriteLine(\"Inorder: \" + string.Join(\", \", bst.Inorder()));\nConsole.WriteLine(\"Search 40: \" + (bst.Search(40) != null));\nbst.Delete(30);  // Delete node with two children\nConsole.WriteLine(\"After delete: \" + string.Join(\", \", bst.Inorder()));"
}
