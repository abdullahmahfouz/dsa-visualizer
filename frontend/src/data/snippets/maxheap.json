{
  "python": "class MaxHeap:\n    \"\"\"Max Heap - Parent always greater than children\"\"\"\n    \n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i): return (i - 1) // 2\n    def left(self, i): return 2 * i + 1\n    def right(self, i): return 2 * i + 2\n    \n    def insert(self, key):\n        \"\"\"Insert and bubble up - O(log n)\"\"\"\n        self.heap.append(key)\n        self._heapify_up(len(self.heap) - 1)\n    \n    def _heapify_up(self, i):\n        \"\"\"Move element up to maintain heap property\"\"\"\n        while i > 0 and self.heap[i] > self.heap[self.parent(i)]:\n            p = self.parent(i)\n            self.heap[i], self.heap[p] = self.heap[p], self.heap[i]\n            i = p\n    \n    def extract_max(self):\n        \"\"\"Remove and return max - O(log n)\"\"\"\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        max_val = self.heap[0]\n        self.heap[0] = self.heap.pop()  # Move last to root\n        self._heapify_down(0)\n        return max_val\n    \n    def _heapify_down(self, i):\n        \"\"\"Move element down to maintain heap property\"\"\"\n        largest = i\n        l, r = self.left(i), self.right(i)\n        \n        if l < len(self.heap) and self.heap[l] > self.heap[largest]:\n            largest = l\n        if r < len(self.heap) and self.heap[r] > self.heap[largest]:\n            largest = r\n        \n        if largest != i:\n            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]\n            self._heapify_down(largest)\n    \n    def peek(self):\n        \"\"\"Get max without removing - O(1)\"\"\"\n        return self.heap[0] if self.heap else None\n    \n    def build_heap(self, arr):\n        \"\"\"Build heap from array - O(n)\"\"\"\n        self.heap = arr[:]\n        # Start from last non-leaf and heapify down\n        for i in range(len(self.heap) // 2 - 1, -1, -1):\n            self._heapify_down(i)\n\n# Usage\nheap = MaxHeap()\nfor val in [5, 3, 8, 1, 2, 9]:\n    heap.insert(val)\n\nprint(\"Max:\", heap.peek())  # 9\nprint(\"Extract:\", heap.extract_max())  # 9\nprint(\"New max:\", heap.peek())  # 8",

  "javascript": "class MaxHeap {\n    // Max Heap - Parent always greater than children\n    \n    constructor() {\n        this.heap = [];\n    }\n    \n    parent(i) { return Math.floor((i - 1) / 2); }\n    left(i) { return 2 * i + 1; }\n    right(i) { return 2 * i + 2; }\n    \n    insert(key) {\n        // Insert and bubble up - O(log n)\n        this.heap.push(key);\n        this._heapifyUp(this.heap.length - 1);\n    }\n    \n    _heapifyUp(i) {\n        while (i > 0 && this.heap[i] > this.heap[this.parent(i)]) {\n            const p = this.parent(i);\n            [this.heap[i], this.heap[p]] = [this.heap[p], this.heap[i]];\n            i = p;\n        }\n    }\n    \n    extractMax() {\n        // Remove and return max - O(log n)\n        if (this.heap.length === 0) return null;\n        if (this.heap.length === 1) return this.heap.pop();\n        \n        const max = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this._heapifyDown(0);\n        return max;\n    }\n    \n    _heapifyDown(i) {\n        let largest = i;\n        const l = this.left(i), r = this.right(i);\n        \n        if (l < this.heap.length && this.heap[l] > this.heap[largest])\n            largest = l;\n        if (r < this.heap.length && this.heap[r] > this.heap[largest])\n            largest = r;\n        \n        if (largest !== i) {\n            [this.heap[i], this.heap[largest]] = [this.heap[largest], this.heap[i]];\n            this._heapifyDown(largest);\n        }\n    }\n    \n    peek() { return this.heap[0] ?? null; }\n    \n    buildHeap(arr) {\n        this.heap = [...arr];\n        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--)\n            this._heapifyDown(i);\n    }\n}\n\n// Usage\nconst heap = new MaxHeap();\n[5, 3, 8, 1, 2, 9].forEach(v => heap.insert(v));\nconsole.log(\"Max:\", heap.peek());  // 9\nconsole.log(\"Extract:\", heap.extractMax());  // 9",

  "java": "import java.util.*;\n\npublic class MaxHeap {\n    // Max Heap - Parent always greater than children\n    private List<Integer> heap = new ArrayList<>();\n    \n    int parent(int i) { return (i - 1) / 2; }\n    int left(int i) { return 2 * i + 1; }\n    int right(int i) { return 2 * i + 2; }\n    \n    public void insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.add(key);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    private void heapifyUp(int i) {\n        while (i > 0 && heap.get(i) > heap.get(parent(i))) {\n            int p = parent(i);\n            Collections.swap(heap, i, p);\n            i = p;\n        }\n    }\n    \n    public Integer extractMax() {\n        // Remove and return max - O(log n)\n        if (heap.isEmpty()) return null;\n        if (heap.size() == 1) return heap.remove(0);\n        \n        int max = heap.get(0);\n        heap.set(0, heap.remove(heap.size() - 1));\n        heapifyDown(0);\n        return max;\n    }\n    \n    private void heapifyDown(int i) {\n        int largest = i;\n        int l = left(i), r = right(i);\n        \n        if (l < heap.size() && heap.get(l) > heap.get(largest))\n            largest = l;\n        if (r < heap.size() && heap.get(r) > heap.get(largest))\n            largest = r;\n        \n        if (largest != i) {\n            Collections.swap(heap, i, largest);\n            heapifyDown(largest);\n        }\n    }\n    \n    public Integer peek() {\n        return heap.isEmpty() ? null : heap.get(0);\n    }\n    \n    public void buildHeap(int[] arr) {\n        heap.clear();\n        for (int v : arr) heap.add(v);\n        for (int i = heap.size() / 2 - 1; i >= 0; i--)\n            heapifyDown(i);\n    }\n}\n\n// Usage\nMaxHeap heap = new MaxHeap();\nfor (int v : new int[]{5, 3, 8, 1, 2, 9}) heap.insert(v);\nSystem.out.println(\"Max: \" + heap.peek());  // 9",

  "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass MaxHeap {\n    // Max Heap - Parent always greater than children\n    vector<int> heap;\n    \n    int parent(int i) { return (i - 1) / 2; }\n    int left(int i) { return 2 * i + 1; }\n    int right(int i) { return 2 * i + 2; }\n    \n    void heapifyUp(int i) {\n        while (i > 0 && heap[i] > heap[parent(i)]) {\n            swap(heap[i], heap[parent(i)]);\n            i = parent(i);\n        }\n    }\n    \n    void heapifyDown(int i) {\n        int largest = i;\n        int l = left(i), r = right(i);\n        \n        if (l < heap.size() && heap[l] > heap[largest]) largest = l;\n        if (r < heap.size() && heap[r] > heap[largest]) largest = r;\n        \n        if (largest != i) {\n            swap(heap[i], heap[largest]);\n            heapifyDown(largest);\n        }\n    }\n    \npublic:\n    void insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.push_back(key);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    int extractMax() {\n        // Remove and return max - O(log n)\n        if (heap.empty()) return -1;\n        int max = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        if (!heap.empty()) heapifyDown(0);\n        return max;\n    }\n    \n    int peek() { return heap.empty() ? -1 : heap[0]; }\n    \n    void buildHeap(vector<int>& arr) {\n        // Build heap from array - O(n)\n        heap = arr;\n        for (int i = heap.size() / 2 - 1; i >= 0; i--)\n            heapifyDown(i);\n    }\n};\n\n// Usage: MaxHeap h; for(int v:{5,3,8,1,9}) h.insert(v);",

  "c#": "using System.Collections.Generic;\n\npublic class MaxHeap {\n    // Max Heap - Parent always greater than children\n    private List<int> heap = new List<int>();\n    \n    int Parent(int i) => (i - 1) / 2;\n    int Left(int i) => 2 * i + 1;\n    int Right(int i) => 2 * i + 2;\n    \n    public void Insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.Add(key);\n        HeapifyUp(heap.Count - 1);\n    }\n    \n    private void HeapifyUp(int i) {\n        while (i > 0 && heap[i] > heap[Parent(i)]) {\n            int p = Parent(i);\n            (heap[i], heap[p]) = (heap[p], heap[i]);\n            i = p;\n        }\n    }\n    \n    public int? ExtractMax() {\n        // Remove and return max - O(log n)\n        if (heap.Count == 0) return null;\n        int max = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        if (heap.Count > 0) HeapifyDown(0);\n        return max;\n    }\n    \n    private void HeapifyDown(int i) {\n        int largest = i;\n        int l = Left(i), r = Right(i);\n        \n        if (l < heap.Count && heap[l] > heap[largest]) largest = l;\n        if (r < heap.Count && heap[r] > heap[largest]) largest = r;\n        \n        if (largest != i) {\n            (heap[i], heap[largest]) = (heap[largest], heap[i]);\n            HeapifyDown(largest);\n        }\n    }\n    \n    public int? Peek() => heap.Count > 0 ? heap[0] : null;\n    \n    public void BuildHeap(int[] arr) {\n        heap = new List<int>(arr);\n        for (int i = heap.Count / 2 - 1; i >= 0; i--)\n            HeapifyDown(i);\n    }\n}\n\n// Usage: var h = new MaxHeap(); foreach(var v in new[]{5,3,8,9}) h.Insert(v);"
}
