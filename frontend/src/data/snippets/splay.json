{
  "python": "class SplayNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass SplayTree:\n    \"\"\"Self-adjusting BST - accessed nodes move to root\"\"\"\n    \n    def __init__(self):\n        self.root = None\n    \n    def _rotate_right(self, x):\n        y = x.left\n        x.left = y.right\n        y.right = x\n        return y\n    \n    def _rotate_left(self, x):\n        y = x.right\n        x.right = y.left\n        y.left = x\n        return y\n    \n    def _splay(self, root, key):\n        \"\"\"Splay operation - bring key to root\"\"\"\n        if not root or root.key == key:\n            return root\n        \n        # Key in left subtree\n        if key < root.key:\n            if not root.left:\n                return root\n            # Zig-Zig (Left Left)\n            if key < root.left.key:\n                root.left.left = self._splay(root.left.left, key)\n                root = self._rotate_right(root)\n            # Zig-Zag (Left Right)\n            elif key > root.left.key:\n                root.left.right = self._splay(root.left.right, key)\n                if root.left.right:\n                    root.left = self._rotate_left(root.left)\n            return root if not root.left else self._rotate_right(root)\n        \n        # Key in right subtree\n        else:\n            if not root.right:\n                return root\n            # Zig-Zag (Right Left)\n            if key < root.right.key:\n                root.right.left = self._splay(root.right.left, key)\n                if root.right.left:\n                    root.right = self._rotate_right(root.right)\n            # Zig-Zig (Right Right)\n            elif key > root.right.key:\n                root.right.right = self._splay(root.right.right, key)\n                root = self._rotate_left(root)\n            return root if not root.right else self._rotate_left(root)\n    \n    def search(self, key):\n        \"\"\"Search and splay to root - O(log n) amortized\"\"\"\n        self.root = self._splay(self.root, key)\n        return self.root if self.root and self.root.key == key else None\n    \n    def insert(self, key):\n        \"\"\"Insert and splay new node to root\"\"\"\n        if not self.root:\n            self.root = SplayNode(key)\n            return\n        \n        self.root = self._splay(self.root, key)\n        if self.root.key == key:\n            return  # Key exists\n        \n        node = SplayNode(key)\n        if key < self.root.key:\n            node.right = self.root\n            node.left = self.root.left\n            self.root.left = None\n        else:\n            node.left = self.root\n            node.right = self.root.right\n            self.root.right = None\n        self.root = node\n\n# Usage\nsplay = SplayTree()\nfor val in [50, 30, 70, 20, 40]:\n    splay.insert(val)\n\nsplay.search(20)  # 20 is now at root!\nprint(\"Root:\", splay.root.key)  # 20",

  "javascript": "class SplayNode {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass SplayTree {\n    // Self-adjusting BST - accessed nodes move to root\n    \n    constructor() {\n        this.root = null;\n    }\n    \n    _rotateRight(x) {\n        const y = x.left;\n        x.left = y.right;\n        y.right = x;\n        return y;\n    }\n    \n    _rotateLeft(x) {\n        const y = x.right;\n        x.right = y.left;\n        y.left = x;\n        return y;\n    }\n    \n    _splay(root, key) {\n        if (!root || root.key === key) return root;\n        \n        if (key < root.key) {\n            if (!root.left) return root;\n            if (key < root.left.key) {\n                root.left.left = this._splay(root.left.left, key);\n                root = this._rotateRight(root);\n            } else if (key > root.left.key) {\n                root.left.right = this._splay(root.left.right, key);\n                if (root.left.right) root.left = this._rotateLeft(root.left);\n            }\n            return !root.left ? root : this._rotateRight(root);\n        } else {\n            if (!root.right) return root;\n            if (key < root.right.key) {\n                root.right.left = this._splay(root.right.left, key);\n                if (root.right.left) root.right = this._rotateRight(root.right);\n            } else if (key > root.right.key) {\n                root.right.right = this._splay(root.right.right, key);\n                root = this._rotateLeft(root);\n            }\n            return !root.right ? root : this._rotateLeft(root);\n        }\n    }\n    \n    search(key) {\n        this.root = this._splay(this.root, key);\n        return this.root?.key === key ? this.root : null;\n    }\n    \n    insert(key) {\n        if (!this.root) { this.root = new SplayNode(key); return; }\n        this.root = this._splay(this.root, key);\n        if (this.root.key === key) return;\n        \n        const node = new SplayNode(key);\n        if (key < this.root.key) {\n            node.right = this.root;\n            node.left = this.root.left;\n            this.root.left = null;\n        } else {\n            node.left = this.root;\n            node.right = this.root.right;\n            this.root.right = null;\n        }\n        this.root = node;\n    }\n}\n\n// Usage\nconst splay = new SplayTree();\n[50, 30, 70, 20].forEach(v => splay.insert(v));\nsplay.search(20); // 20 moves to root",

  "java": "class SplayNode {\n    int key;\n    SplayNode left, right;\n    SplayNode(int key) { this.key = key; }\n}\n\npublic class SplayTree {\n    // Self-adjusting BST - accessed nodes move to root\n    private SplayNode root;\n    \n    private SplayNode rotateRight(SplayNode x) {\n        SplayNode y = x.left;\n        x.left = y.right;\n        y.right = x;\n        return y;\n    }\n    \n    private SplayNode rotateLeft(SplayNode x) {\n        SplayNode y = x.right;\n        x.right = y.left;\n        y.left = x;\n        return y;\n    }\n    \n    private SplayNode splay(SplayNode root, int key) {\n        if (root == null || root.key == key) return root;\n        \n        if (key < root.key) {\n            if (root.left == null) return root;\n            if (key < root.left.key) {\n                root.left.left = splay(root.left.left, key);\n                root = rotateRight(root);\n            } else if (key > root.left.key) {\n                root.left.right = splay(root.left.right, key);\n                if (root.left.right != null)\n                    root.left = rotateLeft(root.left);\n            }\n            return root.left == null ? root : rotateRight(root);\n        } else {\n            if (root.right == null) return root;\n            if (key < root.right.key) {\n                root.right.left = splay(root.right.left, key);\n                if (root.right.left != null)\n                    root.right = rotateRight(root.right);\n            } else if (key > root.right.key) {\n                root.right.right = splay(root.right.right, key);\n                root = rotateLeft(root);\n            }\n            return root.right == null ? root : rotateLeft(root);\n        }\n    }\n    \n    public SplayNode search(int key) {\n        root = splay(root, key);\n        return (root != null && root.key == key) ? root : null;\n    }\n    \n    public void insert(int key) {\n        if (root == null) { root = new SplayNode(key); return; }\n        root = splay(root, key);\n        if (root.key == key) return;\n        \n        SplayNode node = new SplayNode(key);\n        if (key < root.key) {\n            node.right = root;\n            node.left = root.left;\n            root.left = null;\n        } else {\n            node.left = root;\n            node.right = root.right;\n            root.right = null;\n        }\n        root = node;\n    }\n}\n\n// Usage\nSplayTree st = new SplayTree();\nfor (int v : new int[]{50, 30, 70, 20}) st.insert(v);\nst.search(20); // 20 is now root",

  "c++": "struct SplayNode {\n    int key;\n    SplayNode *left, *right;\n    SplayNode(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n\nclass SplayTree {\n    // Self-adjusting BST - accessed nodes move to root\n    SplayNode* root = nullptr;\n    \n    SplayNode* rotateRight(SplayNode* x) {\n        SplayNode* y = x->left;\n        x->left = y->right;\n        y->right = x;\n        return y;\n    }\n    \n    SplayNode* rotateLeft(SplayNode* x) {\n        SplayNode* y = x->right;\n        x->right = y->left;\n        y->left = x;\n        return y;\n    }\n    \n    SplayNode* splay(SplayNode* root, int key) {\n        if (!root || root->key == key) return root;\n        \n        if (key < root->key) {\n            if (!root->left) return root;\n            if (key < root->left->key) {\n                root->left->left = splay(root->left->left, key);\n                root = rotateRight(root);\n            } else if (key > root->left->key) {\n                root->left->right = splay(root->left->right, key);\n                if (root->left->right) root->left = rotateLeft(root->left);\n            }\n            return !root->left ? root : rotateRight(root);\n        } else {\n            if (!root->right) return root;\n            if (key < root->right->key) {\n                root->right->left = splay(root->right->left, key);\n                if (root->right->left) root->right = rotateRight(root->right);\n            } else if (key > root->right->key) {\n                root->right->right = splay(root->right->right, key);\n                root = rotateLeft(root);\n            }\n            return !root->right ? root : rotateLeft(root);\n        }\n    }\n    \npublic:\n    SplayNode* search(int key) {\n        root = splay(root, key);\n        return (root && root->key == key) ? root : nullptr;\n    }\n    \n    void insert(int key) {\n        if (!root) { root = new SplayNode(key); return; }\n        root = splay(root, key);\n        if (root->key == key) return;\n        \n        SplayNode* node = new SplayNode(key);\n        if (key < root->key) {\n            node->right = root; node->left = root->left; root->left = nullptr;\n        } else {\n            node->left = root; node->right = root->right; root->right = nullptr;\n        }\n        root = node;\n    }\n};\n\n// Usage: SplayTree st; for(int v:{50,30,70,20}) st.insert(v);",

  "c#": "public class SplayNode {\n    public int Key { get; set; }\n    public SplayNode Left { get; set; }\n    public SplayNode Right { get; set; }\n    public SplayNode(int key) { Key = key; }\n}\n\npublic class SplayTree {\n    // Self-adjusting BST - accessed nodes move to root\n    private SplayNode root;\n    \n    private SplayNode RotateRight(SplayNode x) {\n        var y = x.Left; x.Left = y.Right; y.Right = x; return y;\n    }\n    \n    private SplayNode RotateLeft(SplayNode x) {\n        var y = x.Right; x.Right = y.Left; y.Left = x; return y;\n    }\n    \n    private SplayNode Splay(SplayNode root, int key) {\n        if (root == null || root.Key == key) return root;\n        \n        if (key < root.Key) {\n            if (root.Left == null) return root;\n            if (key < root.Left.Key) {\n                root.Left.Left = Splay(root.Left.Left, key);\n                root = RotateRight(root);\n            } else if (key > root.Left.Key) {\n                root.Left.Right = Splay(root.Left.Right, key);\n                if (root.Left.Right != null) root.Left = RotateLeft(root.Left);\n            }\n            return root.Left == null ? root : RotateRight(root);\n        } else {\n            if (root.Right == null) return root;\n            if (key < root.Right.Key) {\n                root.Right.Left = Splay(root.Right.Left, key);\n                if (root.Right.Left != null) root.Right = RotateRight(root.Right);\n            } else if (key > root.Right.Key) {\n                root.Right.Right = Splay(root.Right.Right, key);\n                root = RotateLeft(root);\n            }\n            return root.Right == null ? root : RotateLeft(root);\n        }\n    }\n    \n    public SplayNode Search(int key) {\n        root = Splay(root, key);\n        return root?.Key == key ? root : null;\n    }\n    \n    public void Insert(int key) {\n        if (root == null) { root = new SplayNode(key); return; }\n        root = Splay(root, key);\n        if (root.Key == key) return;\n        \n        var node = new SplayNode(key);\n        if (key < root.Key) {\n            node.Right = root; node.Left = root.Left; root.Left = null;\n        } else {\n            node.Left = root; node.Right = root.Right; root.Right = null;\n        }\n        root = node;\n    }\n}\n\n// Usage: var st = new SplayTree(); foreach(var v in new[]{50,30,70}) st.Insert(v);"
}
