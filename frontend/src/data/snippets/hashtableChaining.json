{
  "python": "class Node:\n    \"\"\"Node for linked list in each bucket\"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n\n\nclass HashTableChaining:\n    \"\"\"\n    Hash Table with Separate Chaining\n    Each bucket contains a linked list of key-value pairs\n    \"\"\"\n    \n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.size = 0\n        self.table = [None] * capacity\n    \n    def _hash(self, key):\n        \"\"\"Hash function - O(k) where k is key length\"\"\"\n        return hash(key) % self.capacity\n    \n    def insert(self, key, value):\n        \"\"\"\n        Insert or update key-value pair\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        \"\"\"\n        index = self._hash(key)\n        \n        # Empty bucket - create new node\n        if self.table[index] is None:\n            self.table[index] = Node(key, value)\n            self.size += 1\n            return\n        \n        # Traverse chain to find key or end\n        current = self.table[index]\n        while current:\n            if current.key == key:\n                current.value = value  # Update existing\n                return\n            if current.next is None:\n                break\n            current = current.next\n        \n        # Append new node (collision)\n        current.next = Node(key, value)\n        self.size += 1\n    \n    def search(self, key):\n        \"\"\"\n        Search for value by key\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        \"\"\"\n        index = self._hash(key)\n        current = self.table[index]\n        \n        while current:\n            if current.key == key:\n                return current.value\n            current = current.next\n        return None\n    \n    def delete(self, key):\n        \"\"\"\n        Delete key-value pair\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        \"\"\"\n        index = self._hash(key)\n        \n        if self.table[index] is None:\n            return False\n        \n        # Check head node\n        if self.table[index].key == key:\n            self.table[index] = self.table[index].next\n            self.size -= 1\n            return True\n        \n        # Search rest of chain\n        current = self.table[index]\n        while current.next:\n            if current.next.key == key:\n                current.next = current.next.next\n                self.size -= 1\n                return True\n            current = current.next\n        return False\n\n\n# Usage\nht = HashTableChaining(7)\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 8)  # May collide\nprint(ht.search(\"apple\"))  # 5\nht.delete(\"banana\")",

  "javascript": "class Node {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.next = null;\n    }\n}\n\nclass HashTableChaining {\n    /**\n     * Hash Table with Separate Chaining\n     * Each bucket contains a linked list of key-value pairs\n     */\n    constructor(capacity = 10) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.table = new Array(capacity).fill(null);\n    }\n    \n    _hash(key) {\n        // Hash function - O(k) where k is key length\n        let hash = 0;\n        const str = String(key);\n        for (let i = 0; i < str.length; i++) {\n            hash = (hash * 31 + str.charCodeAt(i)) % this.capacity;\n        }\n        return hash;\n    }\n    \n    insert(key, value) {\n        /**\n         * Insert or update key-value pair\n         * Time: O(1) average, O(n) worst case\n         * Space: O(1)\n         */\n        const index = this._hash(key);\n        \n        // Empty bucket - create new node\n        if (this.table[index] === null) {\n            this.table[index] = new Node(key, value);\n            this.size++;\n            return;\n        }\n        \n        // Traverse chain to find key or end\n        let current = this.table[index];\n        while (current) {\n            if (current.key === key) {\n                current.value = value;  // Update existing\n                return;\n            }\n            if (current.next === null) break;\n            current = current.next;\n        }\n        \n        // Append new node (collision)\n        current.next = new Node(key, value);\n        this.size++;\n    }\n    \n    search(key) {\n        /**\n         * Search for value by key\n         * Time: O(1) average, O(n) worst case\n         * Space: O(1)\n         */\n        const index = this._hash(key);\n        let current = this.table[index];\n        \n        while (current) {\n            if (current.key === key) {\n                return current.value;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    \n    delete(key) {\n        /**\n         * Delete key-value pair\n         * Time: O(1) average, O(n) worst case\n         * Space: O(1)\n         */\n        const index = this._hash(key);\n        \n        if (this.table[index] === null) return false;\n        \n        // Check head node\n        if (this.table[index].key === key) {\n            this.table[index] = this.table[index].next;\n            this.size--;\n            return true;\n        }\n        \n        // Search rest of chain\n        let current = this.table[index];\n        while (current.next) {\n            if (current.next.key === key) {\n                current.next = current.next.next;\n                this.size--;\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n}\n\n// Usage\nconst ht = new HashTableChaining(7);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nconsole.log(ht.search(\"apple\"));  // 5",

  "java": "public class HashTableChaining<K, V> {\n    /**\n     * Hash Table with Separate Chaining\n     * Each bucket contains a linked list of key-value pairs\n     */\n    \n    private class Node {\n        K key;\n        V value;\n        Node next;\n        \n        Node(K key, V value) {\n            this.key = key;\n            this.value = value;\n            this.next = null;\n        }\n    }\n    \n    private Node[] table;\n    private int capacity;\n    private int size;\n    \n    @SuppressWarnings(\"unchecked\")\n    public HashTableChaining(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.table = (Node[]) new HashTableChaining.Node[capacity];\n    }\n    \n    private int hash(K key) {\n        // Hash function - O(1)\n        return Math.abs(key.hashCode() % capacity);\n    }\n    \n    /**\n     * Insert or update key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public void insert(K key, V value) {\n        int index = hash(key);\n        \n        // Empty bucket - create new node\n        if (table[index] == null) {\n            table[index] = new Node(key, value);\n            size++;\n            return;\n        }\n        \n        // Traverse chain to find key or end\n        Node current = table[index];\n        while (current != null) {\n            if (current.key.equals(key)) {\n                current.value = value;  // Update existing\n                return;\n            }\n            if (current.next == null) break;\n            current = current.next;\n        }\n        \n        // Append new node (collision)\n        current.next = new Node(key, value);\n        size++;\n    }\n    \n    /**\n     * Search for value by key\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public V search(K key) {\n        int index = hash(key);\n        Node current = table[index];\n        \n        while (current != null) {\n            if (current.key.equals(key)) {\n                return current.value;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    \n    /**\n     * Delete key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public boolean delete(K key) {\n        int index = hash(key);\n        \n        if (table[index] == null) return false;\n        \n        // Check head node\n        if (table[index].key.equals(key)) {\n            table[index] = table[index].next;\n            size--;\n            return true;\n        }\n        \n        // Search rest of chain\n        Node current = table[index];\n        while (current.next != null) {\n            if (current.next.key.equals(key)) {\n                current.next = current.next.next;\n                size--;\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n}\n\n// Usage\nHashTableChaining<String, Integer> ht = new HashTableChaining<>(7);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nSystem.out.println(ht.search(\"apple\"));  // 5",

  "c++": "#include <iostream>\n#include <string>\n#include <functional>\nusing namespace std;\n\n/**\n * Hash Table with Separate Chaining\n * Each bucket contains a linked list of key-value pairs\n */\ntemplate <typename K, typename V>\nclass HashTableChaining {\nprivate:\n    struct Node {\n        K key;\n        V value;\n        Node* next;\n        Node(K k, V v) : key(k), value(v), next(nullptr) {}\n    };\n    \n    Node** table;\n    int capacity;\n    int size;\n    \n    int hash(const K& key) {\n        // Hash function - O(1)\n        return abs((int)(std::hash<K>{}(key) % capacity));\n    }\n\npublic:\n    HashTableChaining(int cap = 10) : capacity(cap), size(0) {\n        table = new Node*[capacity]();\n    }\n    \n    ~HashTableChaining() {\n        for (int i = 0; i < capacity; i++) {\n            Node* current = table[i];\n            while (current) {\n                Node* temp = current;\n                current = current->next;\n                delete temp;\n            }\n        }\n        delete[] table;\n    }\n    \n    /**\n     * Insert or update key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    void insert(const K& key, const V& value) {\n        int index = hash(key);\n        \n        // Empty bucket - create new node\n        if (table[index] == nullptr) {\n            table[index] = new Node(key, value);\n            size++;\n            return;\n        }\n        \n        // Traverse chain to find key or end\n        Node* current = table[index];\n        while (current) {\n            if (current->key == key) {\n                current->value = value;  // Update existing\n                return;\n            }\n            if (current->next == nullptr) break;\n            current = current->next;\n        }\n        \n        // Append new node (collision)\n        current->next = new Node(key, value);\n        size++;\n    }\n    \n    /**\n     * Search for value by key\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    V* search(const K& key) {\n        int index = hash(key);\n        Node* current = table[index];\n        \n        while (current) {\n            if (current->key == key) {\n                return &current->value;\n            }\n            current = current->next;\n        }\n        return nullptr;\n    }\n    \n    /**\n     * Delete key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    bool remove(const K& key) {\n        int index = hash(key);\n        \n        if (table[index] == nullptr) return false;\n        \n        // Check head node\n        if (table[index]->key == key) {\n            Node* temp = table[index];\n            table[index] = table[index]->next;\n            delete temp;\n            size--;\n            return true;\n        }\n        \n        // Search rest of chain\n        Node* current = table[index];\n        while (current->next) {\n            if (current->next->key == key) {\n                Node* temp = current->next;\n                current->next = current->next->next;\n                delete temp;\n                size--;\n                return true;\n            }\n            current = current->next;\n        }\n        return false;\n    }\n};\n\n// Usage\nint main() {\n    HashTableChaining<string, int> ht(7);\n    ht.insert(\"apple\", 5);\n    ht.insert(\"banana\", 3);\n    int* val = ht.search(\"apple\");\n    if (val) cout << *val << endl;  // 5\n    return 0;\n}",

  "c#": "using System;\n\n/// <summary>\n/// Hash Table with Separate Chaining\n/// Each bucket contains a linked list of key-value pairs\n/// </summary>\npublic class HashTableChaining<K, V>\n{\n    private class Node\n    {\n        public K Key;\n        public V Value;\n        public Node Next;\n        \n        public Node(K key, V value)\n        {\n            Key = key;\n            Value = value;\n            Next = null;\n        }\n    }\n    \n    private Node[] table;\n    private int capacity;\n    private int size;\n    \n    public HashTableChaining(int capacity = 10)\n    {\n        this.capacity = capacity;\n        this.size = 0;\n        this.table = new Node[capacity];\n    }\n    \n    private int Hash(K key)\n    {\n        // Hash function - O(1)\n        return Math.Abs(key.GetHashCode() % capacity);\n    }\n    \n    /// <summary>\n    /// Insert or update key-value pair\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public void Insert(K key, V value)\n    {\n        int index = Hash(key);\n        \n        // Empty bucket - create new node\n        if (table[index] == null)\n        {\n            table[index] = new Node(key, value);\n            size++;\n            return;\n        }\n        \n        // Traverse chain to find key or end\n        Node current = table[index];\n        while (current != null)\n        {\n            if (current.Key.Equals(key))\n            {\n                current.Value = value;  // Update existing\n                return;\n            }\n            if (current.Next == null) break;\n            current = current.Next;\n        }\n        \n        // Append new node (collision)\n        current.Next = new Node(key, value);\n        size++;\n    }\n    \n    /// <summary>\n    /// Search for value by key\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public V Search(K key)\n    {\n        int index = Hash(key);\n        Node current = table[index];\n        \n        while (current != null)\n        {\n            if (current.Key.Equals(key))\n            {\n                return current.Value;\n            }\n            current = current.Next;\n        }\n        return default(V);\n    }\n    \n    /// <summary>\n    /// Delete key-value pair\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public bool Delete(K key)\n    {\n        int index = Hash(key);\n        \n        if (table[index] == null) return false;\n        \n        // Check head node\n        if (table[index].Key.Equals(key))\n        {\n            table[index] = table[index].Next;\n            size--;\n            return true;\n        }\n        \n        // Search rest of chain\n        Node current = table[index];\n        while (current.Next != null)\n        {\n            if (current.Next.Key.Equals(key))\n            {\n                current.Next = current.Next.Next;\n                size--;\n                return true;\n            }\n            current = current.Next;\n        }\n        return false;\n    }\n}\n\n// Usage\nvar ht = new HashTableChaining<string, int>(7);\nht.Insert(\"apple\", 5);\nht.Insert(\"banana\", 3);\nConsole.WriteLine(ht.Search(\"apple\"));  // 5"
}
