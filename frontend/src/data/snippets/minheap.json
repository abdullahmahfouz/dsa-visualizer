{
  "python": "class MinHeap:\n    \"\"\"Min Heap - Parent always smaller than children\"\"\"\n    \n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i): return (i - 1) // 2\n    def left(self, i): return 2 * i + 1\n    def right(self, i): return 2 * i + 2\n    \n    def insert(self, key):\n        \"\"\"Insert and bubble up - O(log n)\"\"\"\n        self.heap.append(key)\n        self._heapify_up(len(self.heap) - 1)\n    \n    def _heapify_up(self, i):\n        \"\"\"Move element up to maintain heap property\"\"\"\n        while i > 0 and self.heap[i] < self.heap[self.parent(i)]:\n            p = self.parent(i)\n            self.heap[i], self.heap[p] = self.heap[p], self.heap[i]\n            i = p\n    \n    def extract_min(self):\n        \"\"\"Remove and return min - O(log n)\"\"\"\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        min_val = self.heap[0]\n        self.heap[0] = self.heap.pop()  # Move last to root\n        self._heapify_down(0)\n        return min_val\n    \n    def _heapify_down(self, i):\n        \"\"\"Move element down to maintain heap property\"\"\"\n        smallest = i\n        l, r = self.left(i), self.right(i)\n        \n        if l < len(self.heap) and self.heap[l] < self.heap[smallest]:\n            smallest = l\n        if r < len(self.heap) and self.heap[r] < self.heap[smallest]:\n            smallest = r\n        \n        if smallest != i:\n            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]\n            self._heapify_down(smallest)\n    \n    def peek(self):\n        \"\"\"Get min without removing - O(1)\"\"\"\n        return self.heap[0] if self.heap else None\n    \n    def build_heap(self, arr):\n        \"\"\"Build heap from array - O(n)\"\"\"\n        self.heap = arr[:]\n        # Start from last non-leaf and heapify down\n        for i in range(len(self.heap) // 2 - 1, -1, -1):\n            self._heapify_down(i)\n\n# Usage\nheap = MinHeap()\nfor val in [5, 3, 8, 1, 2, 9]:\n    heap.insert(val)\n\nprint(\"Min:\", heap.peek())  # 1\nprint(\"Extract:\", heap.extract_min())  # 1\nprint(\"New min:\", heap.peek())  # 2",

  "javascript": "class MinHeap {\n    // Min Heap - Parent always smaller than children\n    \n    constructor() {\n        this.heap = [];\n    }\n    \n    parent(i) { return Math.floor((i - 1) / 2); }\n    left(i) { return 2 * i + 1; }\n    right(i) { return 2 * i + 2; }\n    \n    insert(key) {\n        // Insert and bubble up - O(log n)\n        this.heap.push(key);\n        this._heapifyUp(this.heap.length - 1);\n    }\n    \n    _heapifyUp(i) {\n        while (i > 0 && this.heap[i] < this.heap[this.parent(i)]) {\n            const p = this.parent(i);\n            [this.heap[i], this.heap[p]] = [this.heap[p], this.heap[i]];\n            i = p;\n        }\n    }\n    \n    extractMin() {\n        // Remove and return min - O(log n)\n        if (this.heap.length === 0) return null;\n        if (this.heap.length === 1) return this.heap.pop();\n        \n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this._heapifyDown(0);\n        return min;\n    }\n    \n    _heapifyDown(i) {\n        let smallest = i;\n        const l = this.left(i), r = this.right(i);\n        \n        if (l < this.heap.length && this.heap[l] < this.heap[smallest])\n            smallest = l;\n        if (r < this.heap.length && this.heap[r] < this.heap[smallest])\n            smallest = r;\n        \n        if (smallest !== i) {\n            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];\n            this._heapifyDown(smallest);\n        }\n    }\n    \n    peek() { return this.heap[0] ?? null; }\n    \n    buildHeap(arr) {\n        this.heap = [...arr];\n        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--)\n            this._heapifyDown(i);\n    }\n}\n\n// Usage\nconst heap = new MinHeap();\n[5, 3, 8, 1, 2, 9].forEach(v => heap.insert(v));\nconsole.log(\"Min:\", heap.peek());  // 1\nconsole.log(\"Extract:\", heap.extractMin());  // 1",

  "java": "import java.util.*;\n\npublic class MinHeap {\n    // Min Heap - Parent always smaller than children\n    private List<Integer> heap = new ArrayList<>();\n    \n    int parent(int i) { return (i - 1) / 2; }\n    int left(int i) { return 2 * i + 1; }\n    int right(int i) { return 2 * i + 2; }\n    \n    public void insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.add(key);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    private void heapifyUp(int i) {\n        while (i > 0 && heap.get(i) < heap.get(parent(i))) {\n            int p = parent(i);\n            Collections.swap(heap, i, p);\n            i = p;\n        }\n    }\n    \n    public Integer extractMin() {\n        // Remove and return min - O(log n)\n        if (heap.isEmpty()) return null;\n        if (heap.size() == 1) return heap.remove(0);\n        \n        int min = heap.get(0);\n        heap.set(0, heap.remove(heap.size() - 1));\n        heapifyDown(0);\n        return min;\n    }\n    \n    private void heapifyDown(int i) {\n        int smallest = i;\n        int l = left(i), r = right(i);\n        \n        if (l < heap.size() && heap.get(l) < heap.get(smallest))\n            smallest = l;\n        if (r < heap.size() && heap.get(r) < heap.get(smallest))\n            smallest = r;\n        \n        if (smallest != i) {\n            Collections.swap(heap, i, smallest);\n            heapifyDown(smallest);\n        }\n    }\n    \n    public Integer peek() {\n        return heap.isEmpty() ? null : heap.get(0);\n    }\n    \n    public void buildHeap(int[] arr) {\n        heap.clear();\n        for (int v : arr) heap.add(v);\n        for (int i = heap.size() / 2 - 1; i >= 0; i--)\n            heapifyDown(i);\n    }\n}\n\n// Usage\nMinHeap heap = new MinHeap();\nfor (int v : new int[]{5, 3, 8, 1, 2, 9}) heap.insert(v);\nSystem.out.println(\"Min: \" + heap.peek());  // 1",

  "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass MinHeap {\n    // Min Heap - Parent always smaller than children\n    vector<int> heap;\n    \n    int parent(int i) { return (i - 1) / 2; }\n    int left(int i) { return 2 * i + 1; }\n    int right(int i) { return 2 * i + 2; }\n    \n    void heapifyUp(int i) {\n        while (i > 0 && heap[i] < heap[parent(i)]) {\n            swap(heap[i], heap[parent(i)]);\n            i = parent(i);\n        }\n    }\n    \n    void heapifyDown(int i) {\n        int smallest = i;\n        int l = left(i), r = right(i);\n        \n        if (l < heap.size() && heap[l] < heap[smallest]) smallest = l;\n        if (r < heap.size() && heap[r] < heap[smallest]) smallest = r;\n        \n        if (smallest != i) {\n            swap(heap[i], heap[smallest]);\n            heapifyDown(smallest);\n        }\n    }\n    \npublic:\n    void insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.push_back(key);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    int extractMin() {\n        // Remove and return min - O(log n)\n        if (heap.empty()) return -1;\n        int min = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        if (!heap.empty()) heapifyDown(0);\n        return min;\n    }\n    \n    int peek() { return heap.empty() ? -1 : heap[0]; }\n    \n    void buildHeap(vector<int>& arr) {\n        // Build heap from array - O(n)\n        heap = arr;\n        for (int i = heap.size() / 2 - 1; i >= 0; i--)\n            heapifyDown(i);\n    }\n};\n\n// Usage: MinHeap h; for(int v:{5,3,8,1,2}) h.insert(v);",

  "c#": "using System.Collections.Generic;\n\npublic class MinHeap {\n    // Min Heap - Parent always smaller than children\n    private List<int> heap = new List<int>();\n    \n    int Parent(int i) => (i - 1) / 2;\n    int Left(int i) => 2 * i + 1;\n    int Right(int i) => 2 * i + 2;\n    \n    public void Insert(int key) {\n        // Insert and bubble up - O(log n)\n        heap.Add(key);\n        HeapifyUp(heap.Count - 1);\n    }\n    \n    private void HeapifyUp(int i) {\n        while (i > 0 && heap[i] < heap[Parent(i)]) {\n            int p = Parent(i);\n            (heap[i], heap[p]) = (heap[p], heap[i]);\n            i = p;\n        }\n    }\n    \n    public int? ExtractMin() {\n        // Remove and return min - O(log n)\n        if (heap.Count == 0) return null;\n        int min = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        if (heap.Count > 0) HeapifyDown(0);\n        return min;\n    }\n    \n    private void HeapifyDown(int i) {\n        int smallest = i;\n        int l = Left(i), r = Right(i);\n        \n        if (l < heap.Count && heap[l] < heap[smallest]) smallest = l;\n        if (r < heap.Count && heap[r] < heap[smallest]) smallest = r;\n        \n        if (smallest != i) {\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i]);\n            HeapifyDown(smallest);\n        }\n    }\n    \n    public int? Peek() => heap.Count > 0 ? heap[0] : null;\n    \n    public void BuildHeap(int[] arr) {\n        heap = new List<int>(arr);\n        for (int i = heap.Count / 2 - 1; i >= 0; i--)\n            HeapifyDown(i);\n    }\n}\n\n// Usage: var h = new MinHeap(); foreach(var v in new[]{5,3,8,1}) h.Insert(v);"
}
