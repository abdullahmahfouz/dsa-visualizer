{
  "python": "class HashTableQuadratic:\n    \"\"\"\n    Hash Table with Quadratic Probing\n    Collision resolution: index = (hash + i²) % capacity\n    \"\"\"\n    \n    def __init__(self, capacity=11):\n        \"\"\"Initialize with prime capacity for better distribution\"\"\"\n        self.capacity = capacity\n        self.size = 0\n        self.keys = [None] * capacity\n        self.values = [None] * capacity\n        self.deleted = [False] * capacity  # Lazy deletion marker\n    \n    def _hash(self, key):\n        \"\"\"Hash function - O(k) where k is key length\"\"\"\n        return hash(key) % self.capacity\n    \n    def insert(self, key, value):\n        \"\"\"\n        Insert or update key-value pair using quadratic probing\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        Note: May fail if load factor > 0.5\n        \"\"\"\n        if self.size >= self.capacity // 2:\n            raise Exception(\"Load factor too high - rehash needed\")\n        \n        index = self._hash(key)\n        i = 0\n        \n        while i < self.capacity:\n            probe_index = (index + i * i) % self.capacity\n            \n            # Empty slot or deleted slot - can insert\n            if self.keys[probe_index] is None or self.deleted[probe_index]:\n                self.keys[probe_index] = key\n                self.values[probe_index] = value\n                self.deleted[probe_index] = False\n                self.size += 1\n                return probe_index\n            \n            # Key exists - update value\n            if self.keys[probe_index] == key:\n                self.values[probe_index] = value\n                return probe_index\n            \n            i += 1\n        \n        raise Exception(\"Could not find empty slot\")\n    \n    def search(self, key):\n        \"\"\"\n        Search for value by key using quadratic probing\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        \"\"\"\n        index = self._hash(key)\n        i = 0\n        \n        while i < self.capacity:\n            probe_index = (index + i * i) % self.capacity\n            \n            # Empty slot - key not found\n            if self.keys[probe_index] is None and not self.deleted[probe_index]:\n                return None\n            \n            # Found key (and not deleted)\n            if self.keys[probe_index] == key and not self.deleted[probe_index]:\n                return self.values[probe_index]\n            \n            i += 1\n        \n        return None\n    \n    def delete(self, key):\n        \"\"\"\n        Delete key using lazy deletion (mark as deleted)\n        Time: O(1) average, O(n) worst case\n        Space: O(1)\n        \"\"\"\n        index = self._hash(key)\n        i = 0\n        \n        while i < self.capacity:\n            probe_index = (index + i * i) % self.capacity\n            \n            # Empty slot - key not found\n            if self.keys[probe_index] is None and not self.deleted[probe_index]:\n                return False\n            \n            # Found key - mark as deleted\n            if self.keys[probe_index] == key and not self.deleted[probe_index]:\n                self.deleted[probe_index] = True\n                self.size -= 1\n                return True\n            \n            i += 1\n        \n        return False\n\n\n# Usage\nht = HashTableQuadratic(11)  # Prime capacity\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nprint(ht.search(\"apple\"))  # 5\nht.delete(\"banana\")",

  "javascript": "class HashTableQuadratic {\n    /**\n     * Hash Table with Quadratic Probing\n     * Collision resolution: index = (hash + i²) % capacity\n     */\n    constructor(capacity = 11) {\n        // Use prime capacity for better distribution\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = new Array(capacity).fill(null);\n        this.values = new Array(capacity).fill(null);\n        this.deleted = new Array(capacity).fill(false);\n    }\n    \n    _hash(key) {\n        // Hash function - O(k) where k is key length\n        let hash = 0;\n        const str = String(key);\n        for (let i = 0; i < str.length; i++) {\n            hash = (hash * 31 + str.charCodeAt(i)) % this.capacity;\n        }\n        return hash;\n    }\n    \n    /**\n     * Insert or update key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    insert(key, value) {\n        if (this.size >= this.capacity / 2) {\n            throw new Error(\"Load factor too high - rehash needed\");\n        }\n        \n        const index = this._hash(key);\n        let i = 0;\n        \n        while (i < this.capacity) {\n            const probeIndex = (index + i * i) % this.capacity;\n            \n            // Empty or deleted slot - can insert\n            if (this.keys[probeIndex] === null || this.deleted[probeIndex]) {\n                this.keys[probeIndex] = key;\n                this.values[probeIndex] = value;\n                this.deleted[probeIndex] = false;\n                this.size++;\n                return probeIndex;\n            }\n            \n            // Key exists - update\n            if (this.keys[probeIndex] === key) {\n                this.values[probeIndex] = value;\n                return probeIndex;\n            }\n            \n            i++;\n        }\n        \n        throw new Error(\"Could not find empty slot\");\n    }\n    \n    /**\n     * Search for value by key\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    search(key) {\n        const index = this._hash(key);\n        let i = 0;\n        \n        while (i < this.capacity) {\n            const probeIndex = (index + i * i) % this.capacity;\n            \n            if (this.keys[probeIndex] === null && !this.deleted[probeIndex]) {\n                return null;\n            }\n            \n            if (this.keys[probeIndex] === key && !this.deleted[probeIndex]) {\n                return this.values[probeIndex];\n            }\n            \n            i++;\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Delete key using lazy deletion\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    delete(key) {\n        const index = this._hash(key);\n        let i = 0;\n        \n        while (i < this.capacity) {\n            const probeIndex = (index + i * i) % this.capacity;\n            \n            if (this.keys[probeIndex] === null && !this.deleted[probeIndex]) {\n                return false;\n            }\n            \n            if (this.keys[probeIndex] === key && !this.deleted[probeIndex]) {\n                this.deleted[probeIndex] = true;\n                this.size--;\n                return true;\n            }\n            \n            i++;\n        }\n        \n        return false;\n    }\n}\n\n// Usage\nconst ht = new HashTableQuadratic(11);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nconsole.log(ht.search(\"apple\"));  // 5",

  "java": "public class HashTableQuadratic<K, V> {\n    /**\n     * Hash Table with Quadratic Probing\n     * Collision resolution: index = (hash + i²) % capacity\n     */\n    \n    private K[] keys;\n    private V[] values;\n    private boolean[] deleted;\n    private int capacity;\n    private int size;\n    \n    @SuppressWarnings(\"unchecked\")\n    public HashTableQuadratic(int capacity) {\n        // Use prime capacity for better distribution\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = (K[]) new Object[capacity];\n        this.values = (V[]) new Object[capacity];\n        this.deleted = new boolean[capacity];\n    }\n    \n    private int hash(K key) {\n        // Hash function - O(1)\n        return Math.abs(key.hashCode() % capacity);\n    }\n    \n    /**\n     * Insert or update key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public int insert(K key, V value) {\n        if (size >= capacity / 2) {\n            throw new RuntimeException(\"Load factor too high\");\n        }\n        \n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            // Empty or deleted slot\n            if (keys[probeIndex] == null || deleted[probeIndex]) {\n                keys[probeIndex] = key;\n                values[probeIndex] = value;\n                deleted[probeIndex] = false;\n                size++;\n                return probeIndex;\n            }\n            \n            // Key exists - update\n            if (keys[probeIndex].equals(key)) {\n                values[probeIndex] = value;\n                return probeIndex;\n            }\n            \n            i++;\n        }\n        \n        throw new RuntimeException(\"Could not find empty slot\");\n    }\n    \n    /**\n     * Search for value by key\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public V search(K key) {\n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (keys[probeIndex] == null && !deleted[probeIndex]) {\n                return null;\n            }\n            \n            if (keys[probeIndex] != null && \n                keys[probeIndex].equals(key) && !deleted[probeIndex]) {\n                return values[probeIndex];\n            }\n            \n            i++;\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Delete key using lazy deletion\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    public boolean delete(K key) {\n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (keys[probeIndex] == null && !deleted[probeIndex]) {\n                return false;\n            }\n            \n            if (keys[probeIndex] != null && \n                keys[probeIndex].equals(key) && !deleted[probeIndex]) {\n                deleted[probeIndex] = true;\n                size--;\n                return true;\n            }\n            \n            i++;\n        }\n        \n        return false;\n    }\n}\n\n// Usage\nHashTableQuadratic<String, Integer> ht = new HashTableQuadratic<>(11);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nSystem.out.println(ht.search(\"apple\"));  // 5",

  "c++": "#include <iostream>\n#include <string>\n#include <functional>\nusing namespace std;\n\n/**\n * Hash Table with Quadratic Probing\n * Collision resolution: index = (hash + i²) % capacity\n */\ntemplate <typename K, typename V>\nclass HashTableQuadratic {\nprivate:\n    K* keys;\n    V* values;\n    bool* occupied;\n    bool* deleted;\n    int capacity;\n    int size;\n    \n    int hash(const K& key) {\n        return abs((int)(std::hash<K>{}(key) % capacity));\n    }\n\npublic:\n    HashTableQuadratic(int cap = 11) : capacity(cap), size(0) {\n        keys = new K[capacity];\n        values = new V[capacity];\n        occupied = new bool[capacity]();\n        deleted = new bool[capacity]();\n    }\n    \n    ~HashTableQuadratic() {\n        delete[] keys;\n        delete[] values;\n        delete[] occupied;\n        delete[] deleted;\n    }\n    \n    /**\n     * Insert or update key-value pair\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    int insert(const K& key, const V& value) {\n        if (size >= capacity / 2) {\n            throw runtime_error(\"Load factor too high\");\n        }\n        \n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            // Empty or deleted slot\n            if (!occupied[probeIndex] || deleted[probeIndex]) {\n                keys[probeIndex] = key;\n                values[probeIndex] = value;\n                occupied[probeIndex] = true;\n                deleted[probeIndex] = false;\n                size++;\n                return probeIndex;\n            }\n            \n            // Key exists - update\n            if (keys[probeIndex] == key && !deleted[probeIndex]) {\n                values[probeIndex] = value;\n                return probeIndex;\n            }\n            \n            i++;\n        }\n        \n        throw runtime_error(\"Could not find empty slot\");\n    }\n    \n    /**\n     * Search for value by key\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    V* search(const K& key) {\n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (!occupied[probeIndex] && !deleted[probeIndex]) {\n                return nullptr;\n            }\n            \n            if (occupied[probeIndex] && \n                keys[probeIndex] == key && !deleted[probeIndex]) {\n                return &values[probeIndex];\n            }\n            \n            i++;\n        }\n        \n        return nullptr;\n    }\n    \n    /**\n     * Delete key using lazy deletion\n     * Time: O(1) average, O(n) worst case\n     * Space: O(1)\n     */\n    bool remove(const K& key) {\n        int index = hash(key);\n        int i = 0;\n        \n        while (i < capacity) {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (!occupied[probeIndex] && !deleted[probeIndex]) {\n                return false;\n            }\n            \n            if (occupied[probeIndex] && \n                keys[probeIndex] == key && !deleted[probeIndex]) {\n                deleted[probeIndex] = true;\n                size--;\n                return true;\n            }\n            \n            i++;\n        }\n        \n        return false;\n    }\n};\n\n// Usage\nint main() {\n    HashTableQuadratic<string, int> ht(11);\n    ht.insert(\"apple\", 5);\n    ht.insert(\"banana\", 3);\n    int* val = ht.search(\"apple\");\n    if (val) cout << *val << endl;  // 5\n    return 0;\n}",

  "c#": "using System;\n\n/// <summary>\n/// Hash Table with Quadratic Probing\n/// Collision resolution: index = (hash + i²) % capacity\n/// </summary>\npublic class HashTableQuadratic<K, V>\n{\n    private K[] keys;\n    private V[] values;\n    private bool[] deleted;\n    private int capacity;\n    private int size;\n    \n    public HashTableQuadratic(int capacity = 11)\n    {\n        // Use prime capacity for better distribution\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = new K[capacity];\n        this.values = new V[capacity];\n        this.deleted = new bool[capacity];\n    }\n    \n    private int Hash(K key)\n    {\n        return Math.Abs(key.GetHashCode() % capacity);\n    }\n    \n    /// <summary>\n    /// Insert or update key-value pair\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public int Insert(K key, V value)\n    {\n        if (size >= capacity / 2)\n            throw new InvalidOperationException(\"Load factor too high\");\n        \n        int index = Hash(key);\n        int i = 0;\n        \n        while (i < capacity)\n        {\n            int probeIndex = (index + i * i) % capacity;\n            \n            // Empty or deleted slot\n            if (keys[probeIndex] == null || deleted[probeIndex])\n            {\n                keys[probeIndex] = key;\n                values[probeIndex] = value;\n                deleted[probeIndex] = false;\n                size++;\n                return probeIndex;\n            }\n            \n            // Key exists - update\n            if (keys[probeIndex].Equals(key))\n            {\n                values[probeIndex] = value;\n                return probeIndex;\n            }\n            \n            i++;\n        }\n        \n        throw new InvalidOperationException(\"Could not find empty slot\");\n    }\n    \n    /// <summary>\n    /// Search for value by key\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public V Search(K key)\n    {\n        int index = Hash(key);\n        int i = 0;\n        \n        while (i < capacity)\n        {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (keys[probeIndex] == null && !deleted[probeIndex])\n                return default(V);\n            \n            if (keys[probeIndex] != null && \n                keys[probeIndex].Equals(key) && !deleted[probeIndex])\n                return values[probeIndex];\n            \n            i++;\n        }\n        \n        return default(V);\n    }\n    \n    /// <summary>\n    /// Delete key using lazy deletion\n    /// Time: O(1) average, O(n) worst case\n    /// Space: O(1)\n    /// </summary>\n    public bool Delete(K key)\n    {\n        int index = Hash(key);\n        int i = 0;\n        \n        while (i < capacity)\n        {\n            int probeIndex = (index + i * i) % capacity;\n            \n            if (keys[probeIndex] == null && !deleted[probeIndex])\n                return false;\n            \n            if (keys[probeIndex] != null && \n                keys[probeIndex].Equals(key) && !deleted[probeIndex])\n            {\n                deleted[probeIndex] = true;\n                size--;\n                return true;\n            }\n            \n            i++;\n        }\n        \n        return false;\n    }\n}\n\n// Usage\nvar ht = new HashTableQuadratic<string, int>(11);\nht.Insert(\"apple\", 5);\nht.Insert(\"banana\", 3);\nConsole.WriteLine(ht.Search(\"apple\"));  // 5"
}
