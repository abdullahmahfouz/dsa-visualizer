{
  "python": "class Stack:\n    \"\"\"Stack using Python's dynamic list - simple and Pythonic!\"\"\"\n    \n    def __init__(self):\n        self.items = []  # Dynamic list, no fixed size\n    \n    def push(self, item):\n        \"\"\"Add item to top - O(1) amortized\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"Remove and return top item - O(1)\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Cannot pop from empty stack\")\n        return self.items.pop()\n    \n    def peek(self):\n        \"\"\"View top item without removing - O(1)\"\"\"\n        if self.is_empty():\n            return None\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"Check if stack is empty - O(1)\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Get number of items - O(1)\"\"\"\n        return len(self.items)\n\n# Usage\nstack = Stack()\nstack.push(10)\nstack.push(20)\nstack.push(30)\nprint(stack.pop())   # 30\nprint(stack.peek())  # 20",

  "javascript": "class Stack {\n    constructor(capacity = 100) {\n        this.capacity = capacity;\n        this.items = new Array(capacity);\n        this.top = -1;\n    }\n    \n    push(item) {\n        if (this.top >= this.capacity - 1) {\n            throw new Error(\"Stack is full\");\n        }\n        this.top++;\n        this.items[this.top] = item;\n    }\n    \n    pop() {\n        if (this.isEmpty()) {\n            throw new Error(\"Stack is empty\");\n        }\n        const item = this.items[this.top];\n        this.items[this.top] = undefined;\n        this.top--;\n        return item;\n    }\n    \n    peek() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this.items[this.top];\n    }\n    \n    isEmpty() {\n        return this.top === -1;\n    }\n    \n    size() {\n        return this.top + 1;\n    }\n}\n\n// Usage\nconst stack = new Stack(100);\nstack.push(10);\nstack.push(20);\nconsole.log(stack.pop()); // 20",

  "java": "import java.util.EmptyStackException;\n\npublic class Stack<T> {\n    private Object[] items;\n    private int top;\n    private int capacity;\n    \n    public Stack(int capacity) {\n        this.capacity = capacity;\n        this.items = new Object[capacity];\n        this.top = -1;\n    }\n    \n    public void push(T item) {\n        if (top >= capacity - 1) {\n            throw new StackOverflowError(\"Stack is full\");\n        }\n        items[++top] = item;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        T item = (T) items[top];\n        items[top--] = null;\n        return item;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T peek() {\n        if (isEmpty()) {\n            return null;\n        }\n        return (T) items[top];\n    }\n    \n    public boolean isEmpty() {\n        return top == -1;\n    }\n    \n    public int size() {\n        return top + 1;\n    }\n}\n\n// Usage\nStack<Integer> stack = new Stack<>(100);\nstack.push(10);\nstack.push(20);\nSystem.out.println(stack.pop()); // 20",

  "c++": "#include <iostream>\n#include <stdexcept>\n\ntemplate <typename T>\nclass Stack {\nprivate:\n    T* items;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int cap = 100) : capacity(cap), top(-1) {\n        items = new T[capacity];\n    }\n    \n    ~Stack() {\n        delete[] items;\n    }\n    \n    void push(const T& item) {\n        if (top >= capacity - 1) {\n            throw std::overflow_error(\"Stack is full\");\n        }\n        items[++top] = item;\n    }\n    \n    T pop() {\n        if (isEmpty()) {\n            throw std::underflow_error(\"Stack is empty\");\n        }\n        return items[top--];\n    }\n    \n    T peek() const {\n        if (isEmpty()) {\n            throw std::underflow_error(\"Stack is empty\");\n        }\n        return items[top];\n    }\n    \n    bool isEmpty() const {\n        return top == -1;\n    }\n    \n    int size() const {\n        return top + 1;\n    }\n};\n\n// Usage\nint main() {\n    Stack<int> stack(100);\n    stack.push(10);\n    stack.push(20);\n    std::cout << stack.pop() << std::endl; // 20\n    return 0;\n}",

  "c#": "using System;\n\npublic class Stack<T>\n{\n    private T[] items;\n    private int top;\n    private int capacity;\n    \n    public Stack(int capacity = 100)\n    {\n        this.capacity = capacity;\n        this.items = new T[capacity];\n        this.top = -1;\n    }\n    \n    public void Push(T item)\n    {\n        if (top >= capacity - 1)\n            throw new StackOverflowException(\"Stack is full\");\n        items[++top] = item;\n    }\n    \n    public T Pop()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Stack is empty\");\n        return items[top--];\n    }\n    \n    public T Peek()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Stack is empty\");\n        return items[top];\n    }\n    \n    public bool IsEmpty() => top == -1;\n    \n    public int Size() => top + 1;\n}\n\n// Usage\nvar stack = new Stack<int>(100);\nstack.Push(10);\nstack.Push(20);\nConsole.WriteLine(stack.Pop()); // 20"
}
