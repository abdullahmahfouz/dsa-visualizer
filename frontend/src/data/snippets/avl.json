{
  "python": "class AVLNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    \"\"\"Self-balancing BST with O(log n) guaranteed\"\"\"\n    \n    def __init__(self):\n        self.root = None\n    \n    def height(self, node):\n        return node.height if node else 0\n    \n    def balance_factor(self, node):\n        return self.height(node.left) - self.height(node.right) if node else 0\n    \n    def rotate_right(self, y):\n        \"\"\"Right rotation for Left-Left case\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        y.height = 1 + max(self.height(y.left), self.height(y.right))\n        x.height = 1 + max(self.height(x.left), self.height(x.right))\n        return x\n    \n    def rotate_left(self, x):\n        \"\"\"Left rotation for Right-Right case\"\"\"\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        x.height = 1 + max(self.height(x.left), self.height(x.right))\n        y.height = 1 + max(self.height(y.left), self.height(y.right))\n        return y\n    \n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n    \n    def _insert(self, node, key):\n        # Standard BST insert\n        if not node:\n            return AVLNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # No duplicates\n        \n        # Update height\n        node.height = 1 + max(self.height(node.left), self.height(node.right))\n        \n        # Get balance factor and rebalance if needed\n        bf = self.balance_factor(node)\n        \n        # Left Left -> Right rotation\n        if bf > 1 and key < node.left.key:\n            return self.rotate_right(node)\n        # Right Right -> Left rotation\n        if bf < -1 and key > node.right.key:\n            return self.rotate_left(node)\n        # Left Right -> Left-Right rotation\n        if bf > 1 and key > node.left.key:\n            node.left = self.rotate_left(node.left)\n            return self.rotate_right(node)\n        # Right Left -> Right-Left rotation\n        if bf < -1 and key < node.right.key:\n            node.right = self.rotate_right(node.right)\n            return self.rotate_left(node)\n        \n        return node\n\n# Usage\navl = AVLTree()\nfor val in [30, 20, 40, 10, 25, 35, 50]:\n    avl.insert(val)\n# Tree automatically balances after each insert!",

  "javascript": "class AVLNode {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n        this.height = 1;\n    }\n}\n\nclass AVLTree {\n    // Self-balancing BST with O(log n) guaranteed\n    \n    constructor() {\n        this.root = null;\n    }\n    \n    height(node) {\n        return node ? node.height : 0;\n    }\n    \n    balanceFactor(node) {\n        return node ? this.height(node.left) - this.height(node.right) : 0;\n    }\n    \n    rotateRight(y) {\n        // Right rotation for Left-Left case\n        const x = y.left;\n        const T2 = x.right;\n        x.right = y;\n        y.left = T2;\n        y.height = 1 + Math.max(this.height(y.left), this.height(y.right));\n        x.height = 1 + Math.max(this.height(x.left), this.height(x.right));\n        return x;\n    }\n    \n    rotateLeft(x) {\n        // Left rotation for Right-Right case\n        const y = x.right;\n        const T2 = y.left;\n        y.left = x;\n        x.right = T2;\n        x.height = 1 + Math.max(this.height(x.left), this.height(x.right));\n        y.height = 1 + Math.max(this.height(y.left), this.height(y.right));\n        return y;\n    }\n    \n    insert(key) {\n        this.root = this._insert(this.root, key);\n    }\n    \n    _insert(node, key) {\n        if (!node) return new AVLNode(key);\n        \n        if (key < node.key) node.left = this._insert(node.left, key);\n        else if (key > node.key) node.right = this._insert(node.right, key);\n        else return node; // No duplicates\n        \n        node.height = 1 + Math.max(this.height(node.left), this.height(node.right));\n        const bf = this.balanceFactor(node);\n        \n        // Left Left\n        if (bf > 1 && key < node.left.key) return this.rotateRight(node);\n        // Right Right\n        if (bf < -1 && key > node.right.key) return this.rotateLeft(node);\n        // Left Right\n        if (bf > 1 && key > node.left.key) {\n            node.left = this.rotateLeft(node.left);\n            return this.rotateRight(node);\n        }\n        // Right Left\n        if (bf < -1 && key < node.right.key) {\n            node.right = this.rotateRight(node.right);\n            return this.rotateLeft(node);\n        }\n        return node;\n    }\n}\n\n// Usage\nconst avl = new AVLTree();\n[30, 20, 40, 10, 25, 35, 50].forEach(v => avl.insert(v));",

  "java": "class AVLNode {\n    int key, height;\n    AVLNode left, right;\n    AVLNode(int key) { this.key = key; this.height = 1; }\n}\n\npublic class AVLTree {\n    // Self-balancing BST with O(log n) guaranteed\n    private AVLNode root;\n    \n    int height(AVLNode node) { return node == null ? 0 : node.height; }\n    \n    int balanceFactor(AVLNode node) {\n        return node == null ? 0 : height(node.left) - height(node.right);\n    }\n    \n    AVLNode rotateRight(AVLNode y) {\n        AVLNode x = y.left, T2 = x.right;\n        x.right = y;\n        y.left = T2;\n        y.height = 1 + Math.max(height(y.left), height(y.right));\n        x.height = 1 + Math.max(height(x.left), height(x.right));\n        return x;\n    }\n    \n    AVLNode rotateLeft(AVLNode x) {\n        AVLNode y = x.right, T2 = y.left;\n        y.left = x;\n        x.right = T2;\n        x.height = 1 + Math.max(height(x.left), height(x.right));\n        y.height = 1 + Math.max(height(y.left), height(y.right));\n        return y;\n    }\n    \n    public void insert(int key) { root = insert(root, key); }\n    \n    private AVLNode insert(AVLNode node, int key) {\n        if (node == null) return new AVLNode(key);\n        \n        if (key < node.key) node.left = insert(node.left, key);\n        else if (key > node.key) node.right = insert(node.right, key);\n        else return node;\n        \n        node.height = 1 + Math.max(height(node.left), height(node.right));\n        int bf = balanceFactor(node);\n        \n        if (bf > 1 && key < node.left.key) return rotateRight(node);\n        if (bf < -1 && key > node.right.key) return rotateLeft(node);\n        if (bf > 1 && key > node.left.key) {\n            node.left = rotateLeft(node.left);\n            return rotateRight(node);\n        }\n        if (bf < -1 && key < node.right.key) {\n            node.right = rotateRight(node.right);\n            return rotateLeft(node);\n        }\n        return node;\n    }\n}\n\n// Usage\nAVLTree avl = new AVLTree();\nfor (int v : new int[]{30, 20, 40, 10, 25}) avl.insert(v);",

  "c++": "#include <algorithm>\nusing namespace std;\n\nstruct AVLNode {\n    int key, height;\n    AVLNode *left, *right;\n    AVLNode(int k) : key(k), height(1), left(nullptr), right(nullptr) {}\n};\n\nclass AVLTree {\n    // Self-balancing BST with O(log n) guaranteed\n    AVLNode* root = nullptr;\n    \n    int height(AVLNode* n) { return n ? n->height : 0; }\n    int bf(AVLNode* n) { return n ? height(n->left) - height(n->right) : 0; }\n    \n    AVLNode* rotateRight(AVLNode* y) {\n        AVLNode* x = y->left;\n        y->left = x->right;\n        x->right = y;\n        y->height = 1 + max(height(y->left), height(y->right));\n        x->height = 1 + max(height(x->left), height(x->right));\n        return x;\n    }\n    \n    AVLNode* rotateLeft(AVLNode* x) {\n        AVLNode* y = x->right;\n        x->right = y->left;\n        y->left = x;\n        x->height = 1 + max(height(x->left), height(x->right));\n        y->height = 1 + max(height(y->left), height(y->right));\n        return y;\n    }\n    \n    AVLNode* insert(AVLNode* node, int key) {\n        if (!node) return new AVLNode(key);\n        \n        if (key < node->key) node->left = insert(node->left, key);\n        else if (key > node->key) node->right = insert(node->right, key);\n        else return node;\n        \n        node->height = 1 + max(height(node->left), height(node->right));\n        int balance = bf(node);\n        \n        if (balance > 1 && key < node->left->key) return rotateRight(node);\n        if (balance < -1 && key > node->right->key) return rotateLeft(node);\n        if (balance > 1 && key > node->left->key) {\n            node->left = rotateLeft(node->left);\n            return rotateRight(node);\n        }\n        if (balance < -1 && key < node->right->key) {\n            node->right = rotateRight(node->right);\n            return rotateLeft(node);\n        }\n        return node;\n    }\n    \npublic:\n    void insert(int key) { root = insert(root, key); }\n};\n\n// Usage: AVLTree avl; for(int v : {30,20,40,10,25}) avl.insert(v);",

  "c#": "public class AVLNode {\n    public int Key { get; set; }\n    public int Height { get; set; } = 1;\n    public AVLNode Left { get; set; }\n    public AVLNode Right { get; set; }\n    public AVLNode(int key) { Key = key; }\n}\n\npublic class AVLTree {\n    // Self-balancing BST with O(log n) guaranteed\n    private AVLNode root;\n    \n    int Height(AVLNode n) => n?.Height ?? 0;\n    int BalanceFactor(AVLNode n) => n == null ? 0 : Height(n.Left) - Height(n.Right);\n    \n    AVLNode RotateRight(AVLNode y) {\n        var x = y.Left;\n        y.Left = x.Right;\n        x.Right = y;\n        y.Height = 1 + Math.Max(Height(y.Left), Height(y.Right));\n        x.Height = 1 + Math.Max(Height(x.Left), Height(x.Right));\n        return x;\n    }\n    \n    AVLNode RotateLeft(AVLNode x) {\n        var y = x.Right;\n        x.Right = y.Left;\n        y.Left = x;\n        x.Height = 1 + Math.Max(Height(x.Left), Height(x.Right));\n        y.Height = 1 + Math.Max(Height(y.Left), Height(y.Right));\n        return y;\n    }\n    \n    public void Insert(int key) => root = Insert(root, key);\n    \n    private AVLNode Insert(AVLNode node, int key) {\n        if (node == null) return new AVLNode(key);\n        \n        if (key < node.Key) node.Left = Insert(node.Left, key);\n        else if (key > node.Key) node.Right = Insert(node.Right, key);\n        else return node;\n        \n        node.Height = 1 + Math.Max(Height(node.Left), Height(node.Right));\n        int bf = BalanceFactor(node);\n        \n        if (bf > 1 && key < node.Left.Key) return RotateRight(node);\n        if (bf < -1 && key > node.Right.Key) return RotateLeft(node);\n        if (bf > 1 && key > node.Left.Key) {\n            node.Left = RotateLeft(node.Left);\n            return RotateRight(node);\n        }\n        if (bf < -1 && key < node.Right.Key) {\n            node.Right = RotateRight(node.Right);\n            return RotateLeft(node);\n        }\n        return node;\n    }\n}\n\n// Usage: var avl = new AVLTree(); foreach(var v in new[]{30,20,40}) avl.Insert(v);"
}
