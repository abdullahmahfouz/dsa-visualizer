{
  "python": "class Queue:\n    \"\"\"Queue using Python's dynamic list - FIFO principle\"\"\"\n    \n    def __init__(self):\n        self.items = []\n    \n    def enqueue(self, item):\n        \"\"\"Add item to the back - O(1) amortized\"\"\"\n        self.items.append(item)\n    \n    def dequeue(self):\n        \"\"\"Remove and return front item - O(n)\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Cannot dequeue from empty queue\")\n        return self.items.pop(0)\n    \n    def peek(self):\n        \"\"\"View front item without removing - O(1)\"\"\"\n        if self.is_empty():\n            return None\n        return self.items[0]\n    \n    def is_empty(self):\n        \"\"\"Check if queue is empty - O(1)\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Get number of items - O(1)\"\"\"\n        return len(self.items)\n\n# Usage\nqueue = Queue()\nqueue.enqueue(10)\nqueue.enqueue(20)\nqueue.enqueue(30)\nprint(queue.dequeue())  # 10 (first in, first out)\nprint(queue.peek())     # 20",

  "javascript": "class Queue {\n    constructor(capacity = 100) {\n        this.capacity = capacity;\n        this.items = new Array(capacity);\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n    \n    enqueue(item) {\n        if (this.size >= this.capacity) {\n            throw new Error(\"Queue is full\");\n        }\n        this.rear = (this.rear + 1) % this.capacity;\n        this.items[this.rear] = item;\n        this.size++;\n    }\n    \n    dequeue() {\n        if (this.isEmpty()) {\n            throw new Error(\"Queue is empty\");\n        }\n        const item = this.items[this.front];\n        this.items[this.front] = undefined;\n        this.front = (this.front + 1) % this.capacity;\n        this.size--;\n        return item;\n    }\n    \n    peek() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this.items[this.front];\n    }\n    \n    isEmpty() {\n        return this.size === 0;\n    }\n    \n    getSize() {\n        return this.size;\n    }\n}\n\n// Usage\nconst queue = new Queue(100);\nqueue.enqueue(10);\nqueue.enqueue(20);\nconsole.log(queue.dequeue()); // 10",

  "java": "import java.util.NoSuchElementException;\n\npublic class Queue<T> {\n    private Object[] items;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public Queue(int capacity) {\n        this.capacity = capacity;\n        this.items = new Object[capacity];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n    \n    public void enqueue(T item) {\n        if (size >= capacity) {\n            throw new IllegalStateException(\"Queue is full\");\n        }\n        rear = (rear + 1) % capacity;\n        items[rear] = item;\n        size++;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n        T item = (T) items[front];\n        items[front] = null;\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public T peek() {\n        if (isEmpty()) {\n            return null;\n        }\n        return (T) items[front];\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    public int size() {\n        return size;\n    }\n}\n\n// Usage\nQueue<Integer> queue = new Queue<>(100);\nqueue.enqueue(10);\nqueue.enqueue(20);\nSystem.out.println(queue.dequeue()); // 10",

  "c++": "#include <iostream>\n#include <stdexcept>\n\ntemplate <typename T>\nclass Queue {\nprivate:\n    T* items;\n    int front;\n    int rear;\n    int size;\n    int capacity;\n\npublic:\n    Queue(int cap = 100) : capacity(cap), front(0), rear(-1), size(0) {\n        items = new T[capacity];\n    }\n    \n    ~Queue() {\n        delete[] items;\n    }\n    \n    void enqueue(const T& item) {\n        if (size >= capacity) {\n            throw std::overflow_error(\"Queue is full\");\n        }\n        rear = (rear + 1) % capacity;\n        items[rear] = item;\n        size++;\n    }\n    \n    T dequeue() {\n        if (isEmpty()) {\n            throw std::underflow_error(\"Queue is empty\");\n        }\n        T item = items[front];\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n    \n    T peek() const {\n        if (isEmpty()) {\n            throw std::underflow_error(\"Queue is empty\");\n        }\n        return items[front];\n    }\n    \n    bool isEmpty() const {\n        return size == 0;\n    }\n    \n    int getSize() const {\n        return size;\n    }\n};\n\n// Usage\nint main() {\n    Queue<int> queue(100);\n    queue.enqueue(10);\n    queue.enqueue(20);\n    std::cout << queue.dequeue() << std::endl; // 10\n    return 0;\n}",

  "c#": "using System;\n\npublic class Queue<T>\n{\n    private T[] items;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public Queue(int capacity = 100)\n    {\n        this.capacity = capacity;\n        this.items = new T[capacity];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n    \n    public void Enqueue(T item)\n    {\n        if (size >= capacity)\n            throw new InvalidOperationException(\"Queue is full\");\n        rear = (rear + 1) % capacity;\n        items[rear] = item;\n        size++;\n    }\n    \n    public T Dequeue()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Queue is empty\");\n        T item = items[front];\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n    \n    public T Peek()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Queue is empty\");\n        return items[front];\n    }\n    \n    public bool IsEmpty() => size == 0;\n    \n    public int Size => size;\n}\n\n// Usage\nvar queue = new Queue<int>(100);\nqueue.Enqueue(10);\nqueue.Enqueue(20);\nConsole.WriteLine(queue.Dequeue()); // 10"
}
