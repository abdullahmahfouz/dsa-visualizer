{
  "python": "class HashTable:\n    \"\"\"Hash Table with Linear Probing for collision resolution\"\"\"\n    \n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.size = 0\n        self.keys = [None] * capacity\n        self.values = [None] * capacity\n    \n    def _hash(self, key):\n        \"\"\"Simple hash function\"\"\"\n        hash_value = 0\n        for char in str(key):\n            hash_value = (hash_value * 31 + ord(char)) % self.capacity\n        return hash_value\n    \n    def insert(self, key, value):\n        \"\"\"Insert key-value pair - O(1) average\"\"\"\n        index = self._hash(key)\n        original_index = index\n        \n        while self.keys[index] is not None:\n            if self.keys[index] == key:\n                self.values[index] = value  # Update\n                return\n            index = (index + 1) % self.capacity  # Linear probing\n            if index == original_index:\n                raise Exception(\"Hash table is full\")\n        \n        self.keys[index] = key\n        self.values[index] = value\n        self.size += 1\n    \n    def get(self, key):\n        \"\"\"Get value by key - O(1) average\"\"\"\n        index = self._hash(key)\n        original_index = index\n        \n        while self.keys[index] is not None:\n            if self.keys[index] == key:\n                return self.values[index]\n            index = (index + 1) % self.capacity\n            if index == original_index:\n                break\n        return None\n    \n    def delete(self, key):\n        \"\"\"Delete key-value pair - O(1) average\"\"\"\n        index = self._hash(key)\n        original_index = index\n        \n        while self.keys[index] is not None:\n            if self.keys[index] == key:\n                self.keys[index] = None\n                self.values[index] = None\n                self.size -= 1\n                return True\n            index = (index + 1) % self.capacity\n            if index == original_index:\n                break\n        return False\n\n# Usage\nht = HashTable(10)\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"orange\", 8)\nprint(ht.get(\"apple\"))   # 5\nprint(ht.get(\"banana\"))  # 3",

  "javascript": "class HashTable {\n    constructor(capacity = 10) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = new Array(capacity).fill(null);\n        this.values = new Array(capacity).fill(null);\n    }\n    \n    _hash(key) {\n        // Simple hash function\n        let hash = 0;\n        const str = String(key);\n        for (let i = 0; i < str.length; i++) {\n            hash = (hash * 31 + str.charCodeAt(i)) % this.capacity;\n        }\n        return hash;\n    }\n    \n    insert(key, value) {\n        // Insert key-value pair - O(1) average\n        let index = this._hash(key);\n        const originalIndex = index;\n        \n        while (this.keys[index] !== null) {\n            if (this.keys[index] === key) {\n                this.values[index] = value; // Update\n                return;\n            }\n            index = (index + 1) % this.capacity; // Linear probing\n            if (index === originalIndex) {\n                throw new Error(\"Hash table is full\");\n            }\n        }\n        \n        this.keys[index] = key;\n        this.values[index] = value;\n        this.size++;\n    }\n    \n    get(key) {\n        // Get value by key - O(1) average\n        let index = this._hash(key);\n        const originalIndex = index;\n        \n        while (this.keys[index] !== null) {\n            if (this.keys[index] === key) {\n                return this.values[index];\n            }\n            index = (index + 1) % this.capacity;\n            if (index === originalIndex) break;\n        }\n        return null;\n    }\n    \n    delete(key) {\n        // Delete key-value pair - O(1) average\n        let index = this._hash(key);\n        const originalIndex = index;\n        \n        while (this.keys[index] !== null) {\n            if (this.keys[index] === key) {\n                this.keys[index] = null;\n                this.values[index] = null;\n                this.size--;\n                return true;\n            }\n            index = (index + 1) % this.capacity;\n            if (index === originalIndex) break;\n        }\n        return false;\n    }\n}\n\n// Usage\nconst ht = new HashTable(10);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nconsole.log(ht.get(\"apple\"));  // 5",

  "java": "public class HashTable<K, V> {\n    private K[] keys;\n    private V[] values;\n    private int capacity;\n    private int size;\n    \n    @SuppressWarnings(\"unchecked\")\n    public HashTable(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = (K[]) new Object[capacity];\n        this.values = (V[]) new Object[capacity];\n    }\n    \n    private int hash(K key) {\n        // Simple hash function\n        int hash = 0;\n        String str = String.valueOf(key);\n        for (int i = 0; i < str.length(); i++) {\n            hash = (hash * 31 + str.charAt(i)) % capacity;\n        }\n        return Math.abs(hash);\n    }\n    \n    public void insert(K key, V value) {\n        // Insert with linear probing - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (keys[index] != null) {\n            if (keys[index].equals(key)) {\n                values[index] = value; // Update\n                return;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) {\n                throw new RuntimeException(\"Hash table is full\");\n            }\n        }\n        \n        keys[index] = key;\n        values[index] = value;\n        size++;\n    }\n    \n    public V get(K key) {\n        // Get value - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (keys[index] != null) {\n            if (keys[index].equals(key)) {\n                return values[index];\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return null;\n    }\n    \n    public boolean delete(K key) {\n        // Delete key-value pair - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (keys[index] != null) {\n            if (keys[index].equals(key)) {\n                keys[index] = null;\n                values[index] = null;\n                size--;\n                return true;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return false;\n    }\n}\n\n// Usage\nHashTable<String, Integer> ht = new HashTable<>(10);\nht.insert(\"apple\", 5);\nht.insert(\"banana\", 3);\nSystem.out.println(ht.get(\"apple\")); // 5",

  "c++": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass HashTable {\nprivate:\n    vector<string> keys;\n    vector<int> values;\n    vector<bool> occupied;\n    int capacity;\n    int size;\n    \n    int hash(const string& key) {\n        int hashVal = 0;\n        for (char c : key) {\n            hashVal = (hashVal * 31 + c) % capacity;\n        }\n        return abs(hashVal);\n    }\n\npublic:\n    HashTable(int cap = 10) : capacity(cap), size(0) {\n        keys.resize(capacity);\n        values.resize(capacity);\n        occupied.resize(capacity, false);\n    }\n    \n    void insert(const string& key, int value) {\n        // Insert with linear probing - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index]) {\n            if (keys[index] == key) {\n                values[index] = value; // Update\n                return;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) {\n                throw runtime_error(\"Hash table is full\");\n            }\n        }\n        \n        keys[index] = key;\n        values[index] = value;\n        occupied[index] = true;\n        size++;\n    }\n    \n    int get(const string& key) {\n        // Get value - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index]) {\n            if (keys[index] == key) {\n                return values[index];\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return -1; // Not found\n    }\n    \n    bool remove(const string& key) {\n        // Delete key-value pair - O(1) average\n        int index = hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index]) {\n            if (keys[index] == key) {\n                occupied[index] = false;\n                size--;\n                return true;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return false;\n    }\n};\n\n// Usage\nint main() {\n    HashTable ht(10);\n    ht.insert(\"apple\", 5);\n    ht.insert(\"banana\", 3);\n    cout << ht.get(\"apple\") << endl; // 5\n    return 0;\n}",

  "c#": "using System;\n\npublic class HashTable<K, V>\n{\n    private K[] keys;\n    private V[] values;\n    private bool[] occupied;\n    private int capacity;\n    private int size;\n    \n    public HashTable(int capacity = 10)\n    {\n        this.capacity = capacity;\n        this.size = 0;\n        this.keys = new K[capacity];\n        this.values = new V[capacity];\n        this.occupied = new bool[capacity];\n    }\n    \n    private int Hash(K key)\n    {\n        // Simple hash function\n        string str = key.ToString();\n        int hash = 0;\n        foreach (char c in str)\n        {\n            hash = (hash * 31 + c) % capacity;\n        }\n        return Math.Abs(hash);\n    }\n    \n    public void Insert(K key, V value)\n    {\n        // Insert with linear probing - O(1) average\n        int index = Hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index])\n        {\n            if (keys[index].Equals(key))\n            {\n                values[index] = value; // Update\n                return;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex)\n                throw new InvalidOperationException(\"Hash table is full\");\n        }\n        \n        keys[index] = key;\n        values[index] = value;\n        occupied[index] = true;\n        size++;\n    }\n    \n    public V Get(K key)\n    {\n        // Get value - O(1) average\n        int index = Hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index])\n        {\n            if (keys[index].Equals(key))\n                return values[index];\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return default(V);\n    }\n    \n    public bool Delete(K key)\n    {\n        // Delete key-value pair - O(1) average\n        int index = Hash(key);\n        int originalIndex = index;\n        \n        while (occupied[index])\n        {\n            if (keys[index].Equals(key))\n            {\n                occupied[index] = false;\n                size--;\n                return true;\n            }\n            index = (index + 1) % capacity;\n            if (index == originalIndex) break;\n        }\n        return false;\n    }\n}\n\n// Usage\nvar ht = new HashTable<string, int>(10);\nht.Insert(\"apple\", 5);\nht.Insert(\"banana\", 3);\nConsole.WriteLine(ht.Get(\"apple\")); // 5"
}
