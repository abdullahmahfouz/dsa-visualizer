{
  "python": "class TreeNode:\n    \"\"\"Node in a binary tree\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    \"\"\"Binary Search Tree with Traversals\"\"\"\n    \n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def insert(self, data):\n        \"\"\"Insert a value into the BST - O(log n) average\"\"\"\n        if not self.root:\n            self.root = TreeNode(data)\n            self.size += 1\n            return\n        self._insert_recursive(self.root, data)\n        self.size += 1\n    \n    def _insert_recursive(self, node, data):\n        if data < node.data:\n            if node.left is None:\n                node.left = TreeNode(data)\n            else:\n                self._insert_recursive(node.left, data)\n        else:\n            if node.right is None:\n                node.right = TreeNode(data)\n            else:\n                self._insert_recursive(node.right, data)\n    \n    # ============ TRAVERSALS ============\n    \n    def inorder_traversal(self):\n        \"\"\"Left -> Root -> Right (sorted order for BST)\"\"\"\n        result = []\n        self._inorder(self.root, result)\n        return result\n    \n    def _inorder(self, node, result):\n        if node:\n            self._inorder(node.left, result)\n            result.append(node.data)\n            self._inorder(node.right, result)\n    \n    def preorder_traversal(self):\n        \"\"\"Root -> Left -> Right (copy tree structure)\"\"\"\n        result = []\n        self._preorder(self.root, result)\n        return result\n    \n    def _preorder(self, node, result):\n        if node:\n            result.append(node.data)\n            self._preorder(node.left, result)\n            self._preorder(node.right, result)\n    \n    def postorder_traversal(self):\n        \"\"\"Left -> Right -> Root (delete tree safely)\"\"\"\n        result = []\n        self._postorder(self.root, result)\n        return result\n    \n    def _postorder(self, node, result):\n        if node:\n            self._postorder(node.left, result)\n            self._postorder(node.right, result)\n            result.append(node.data)\n    \n    def levelorder_traversal(self):\n        \"\"\"Level by level - BFS (shortest path)\"\"\"\n        if not self.root:\n            return []\n        result = []\n        queue = [self.root]\n        while queue:\n            node = queue.pop(0)\n            result.append(node.data)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        return result\n\n# Usage\ntree = BinaryTree()\nfor val in [50, 30, 70, 20, 40, 60, 80]:\n    tree.insert(val)\n\nprint(\"Inorder:   \", tree.inorder_traversal())     # [20, 30, 40, 50, 60, 70, 80]\nprint(\"Preorder:  \", tree.preorder_traversal())    # [50, 30, 20, 40, 70, 60, 80]\nprint(\"Postorder: \", tree.postorder_traversal())   # [20, 40, 30, 60, 80, 70, 50]\nprint(\"Level:     \", tree.levelorder_traversal())  # [50, 30, 70, 20, 40, 60, 80]",

  "javascript": "class TreeNode {\n    constructor(data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinaryTree {\n    constructor() {\n        this.root = null;\n        this.size = 0;\n    }\n    \n    insert(data) {\n        // Insert into BST - O(log n) average\n        if (!this.root) {\n            this.root = new TreeNode(data);\n            this.size++;\n            return;\n        }\n        this._insertRecursive(this.root, data);\n        this.size++;\n    }\n    \n    _insertRecursive(node, data) {\n        if (data < node.data) {\n            if (!node.left) {\n                node.left = new TreeNode(data);\n            } else {\n                this._insertRecursive(node.left, data);\n            }\n        } else {\n            if (!node.right) {\n                node.right = new TreeNode(data);\n            } else {\n                this._insertRecursive(node.right, data);\n            }\n        }\n    }\n    \n    // ============ TRAVERSALS ============\n    \n    inorderTraversal() {\n        // Left -> Root -> Right (sorted order for BST)\n        const result = [];\n        this._inorder(this.root, result);\n        return result;\n    }\n    \n    _inorder(node, result) {\n        if (node) {\n            this._inorder(node.left, result);\n            result.push(node.data);\n            this._inorder(node.right, result);\n        }\n    }\n    \n    preorderTraversal() {\n        // Root -> Left -> Right (copy tree structure)\n        const result = [];\n        this._preorder(this.root, result);\n        return result;\n    }\n    \n    _preorder(node, result) {\n        if (node) {\n            result.push(node.data);\n            this._preorder(node.left, result);\n            this._preorder(node.right, result);\n        }\n    }\n    \n    postorderTraversal() {\n        // Left -> Right -> Root (delete tree safely)\n        const result = [];\n        this._postorder(this.root, result);\n        return result;\n    }\n    \n    _postorder(node, result) {\n        if (node) {\n            this._postorder(node.left, result);\n            this._postorder(node.right, result);\n            result.push(node.data);\n        }\n    }\n    \n    levelOrderTraversal() {\n        // Level by level - BFS (shortest path)\n        if (!this.root) return [];\n        const result = [];\n        const queue = [this.root];\n        while (queue.length > 0) {\n            const node = queue.shift();\n            result.push(node.data);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        return result;\n    }\n}\n\n// Usage\nconst tree = new BinaryTree();\n[50, 30, 70, 20, 40, 60, 80].forEach(val => tree.insert(val));\n\nconsole.log(\"Inorder:  \", tree.inorderTraversal());     // [20, 30, 40, 50, 60, 70, 80]\nconsole.log(\"Preorder: \", tree.preorderTraversal());    // [50, 30, 20, 40, 70, 60, 80]\nconsole.log(\"Postorder:\", tree.postorderTraversal());   // [20, 40, 30, 60, 80, 70, 50]\nconsole.log(\"Level:    \", tree.levelOrderTraversal());  // [50, 30, 70, 20, 40, 60, 80]",

  "java": "import java.util.*;\n\nclass TreeNode {\n    int data;\n    TreeNode left, right;\n    \n    TreeNode(int data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n\npublic class BinaryTree {\n    private TreeNode root;\n    private int size;\n    \n    public BinaryTree() {\n        this.root = null;\n        this.size = 0;\n    }\n    \n    public void insert(int data) {\n        // Insert into BST - O(log n) average\n        if (root == null) {\n            root = new TreeNode(data);\n            size++;\n            return;\n        }\n        insertRecursive(root, data);\n        size++;\n    }\n    \n    private void insertRecursive(TreeNode node, int data) {\n        if (data < node.data) {\n            if (node.left == null) {\n                node.left = new TreeNode(data);\n            } else {\n                insertRecursive(node.left, data);\n            }\n        } else {\n            if (node.right == null) {\n                node.right = new TreeNode(data);\n            } else {\n                insertRecursive(node.right, data);\n            }\n        }\n    }\n    \n    // ============ TRAVERSALS ============\n    \n    public List<Integer> inorderTraversal() {\n        // Left -> Root -> Right (sorted order for BST)\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result;\n    }\n    \n    private void inorder(TreeNode node, List<Integer> result) {\n        if (node != null) {\n            inorder(node.left, result);\n            result.add(node.data);\n            inorder(node.right, result);\n        }\n    }\n    \n    public List<Integer> preorderTraversal() {\n        // Root -> Left -> Right (copy tree structure)\n        List<Integer> result = new ArrayList<>();\n        preorder(root, result);\n        return result;\n    }\n    \n    private void preorder(TreeNode node, List<Integer> result) {\n        if (node != null) {\n            result.add(node.data);\n            preorder(node.left, result);\n            preorder(node.right, result);\n        }\n    }\n    \n    public List<Integer> postorderTraversal() {\n        // Left -> Right -> Root (delete tree safely)\n        List<Integer> result = new ArrayList<>();\n        postorder(root, result);\n        return result;\n    }\n    \n    private void postorder(TreeNode node, List<Integer> result) {\n        if (node != null) {\n            postorder(node.left, result);\n            postorder(node.right, result);\n            result.add(node.data);\n        }\n    }\n    \n    public List<Integer> levelOrderTraversal() {\n        // Level by level - BFS (shortest path)\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            result.add(node.data);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        return result;\n    }\n}\n\n// Usage\nBinaryTree tree = new BinaryTree();\nfor (int val : new int[]{50, 30, 70, 20, 40, 60, 80}) {\n    tree.insert(val);\n}\n\nSystem.out.println(\"Inorder:   \" + tree.inorderTraversal());\nSystem.out.println(\"Preorder:  \" + tree.preorderTraversal());\nSystem.out.println(\"Postorder: \" + tree.postorderTraversal());\nSystem.out.println(\"Level:     \" + tree.levelOrderTraversal());",

  "c++": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode {\n    int data;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass BinaryTree {\nprivate:\n    TreeNode* root;\n    int size;\n    \n    void insertRecursive(TreeNode* node, int data) {\n        if (data < node->data) {\n            if (!node->left) node->left = new TreeNode(data);\n            else insertRecursive(node->left, data);\n        } else {\n            if (!node->right) node->right = new TreeNode(data);\n            else insertRecursive(node->right, data);\n        }\n    }\n    \n    // Helper functions for traversals\n    void inorder(TreeNode* node, vector<int>& result) {\n        if (node) {\n            inorder(node->left, result);\n            result.push_back(node->data);\n            inorder(node->right, result);\n        }\n    }\n    \n    void preorder(TreeNode* node, vector<int>& result) {\n        if (node) {\n            result.push_back(node->data);\n            preorder(node->left, result);\n            preorder(node->right, result);\n        }\n    }\n    \n    void postorder(TreeNode* node, vector<int>& result) {\n        if (node) {\n            postorder(node->left, result);\n            postorder(node->right, result);\n            result.push_back(node->data);\n        }\n    }\n\npublic:\n    BinaryTree() : root(nullptr), size(0) {}\n    \n    void insert(int data) {\n        // Insert into BST - O(log n) average\n        if (!root) {\n            root = new TreeNode(data);\n            size++;\n            return;\n        }\n        insertRecursive(root, data);\n        size++;\n    }\n    \n    // ============ TRAVERSALS ============\n    \n    vector<int> inorderTraversal() {\n        // Left -> Root -> Right (sorted order for BST)\n        vector<int> result;\n        inorder(root, result);\n        return result;\n    }\n    \n    vector<int> preorderTraversal() {\n        // Root -> Left -> Right (copy tree structure)\n        vector<int> result;\n        preorder(root, result);\n        return result;\n    }\n    \n    vector<int> postorderTraversal() {\n        // Left -> Right -> Root (delete tree safely)\n        vector<int> result;\n        postorder(root, result);\n        return result;\n    }\n    \n    vector<int> levelOrderTraversal() {\n        // Level by level - BFS (shortest path)\n        vector<int> result;\n        if (!root) return result;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            result.push_back(node->data);\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        return result;\n    }\n};\n\n// Usage\nint main() {\n    BinaryTree tree;\n    for (int val : {50, 30, 70, 20, 40, 60, 80}) {\n        tree.insert(val);\n    }\n    \n    // Inorder:   [20, 30, 40, 50, 60, 70, 80]\n    // Preorder:  [50, 30, 20, 40, 70, 60, 80]\n    // Postorder: [20, 40, 30, 60, 80, 70, 50]\n    // Level:     [50, 30, 70, 20, 40, 60, 80]\n    return 0;\n}",

  "c#": "using System;\nusing System.Collections.Generic;\n\npublic class TreeNode\n{\n    public int Data { get; set; }\n    public TreeNode Left { get; set; }\n    public TreeNode Right { get; set; }\n    \n    public TreeNode(int data)\n    {\n        Data = data;\n        Left = null;\n        Right = null;\n    }\n}\n\npublic class BinaryTree\n{\n    private TreeNode root;\n    private int size;\n    \n    public BinaryTree()\n    {\n        root = null;\n        size = 0;\n    }\n    \n    public void Insert(int data)\n    {\n        // Insert into BST - O(log n) average\n        if (root == null)\n        {\n            root = new TreeNode(data);\n            size++;\n            return;\n        }\n        InsertRecursive(root, data);\n        size++;\n    }\n    \n    private void InsertRecursive(TreeNode node, int data)\n    {\n        if (data < node.Data)\n        {\n            if (node.Left == null)\n                node.Left = new TreeNode(data);\n            else\n                InsertRecursive(node.Left, data);\n        }\n        else\n        {\n            if (node.Right == null)\n                node.Right = new TreeNode(data);\n            else\n                InsertRecursive(node.Right, data);\n        }\n    }\n    \n    // ============ TRAVERSALS ============\n    \n    public List<int> InorderTraversal()\n    {\n        // Left -> Root -> Right (sorted order for BST)\n        var result = new List<int>();\n        Inorder(root, result);\n        return result;\n    }\n    \n    private void Inorder(TreeNode node, List<int> result)\n    {\n        if (node != null)\n        {\n            Inorder(node.Left, result);\n            result.Add(node.Data);\n            Inorder(node.Right, result);\n        }\n    }\n    \n    public List<int> PreorderTraversal()\n    {\n        // Root -> Left -> Right (copy tree structure)\n        var result = new List<int>();\n        Preorder(root, result);\n        return result;\n    }\n    \n    private void Preorder(TreeNode node, List<int> result)\n    {\n        if (node != null)\n        {\n            result.Add(node.Data);\n            Preorder(node.Left, result);\n            Preorder(node.Right, result);\n        }\n    }\n    \n    public List<int> PostorderTraversal()\n    {\n        // Left -> Right -> Root (delete tree safely)\n        var result = new List<int>();\n        Postorder(root, result);\n        return result;\n    }\n    \n    private void Postorder(TreeNode node, List<int> result)\n    {\n        if (node != null)\n        {\n            Postorder(node.Left, result);\n            Postorder(node.Right, result);\n            result.Add(node.Data);\n        }\n    }\n    \n    public List<int> LevelOrderTraversal()\n    {\n        // Level by level - BFS (shortest path)\n        var result = new List<int>();\n        if (root == null) return result;\n        var queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        while (queue.Count > 0)\n        {\n            var node = queue.Dequeue();\n            result.Add(node.Data);\n            if (node.Left != null) queue.Enqueue(node.Left);\n            if (node.Right != null) queue.Enqueue(node.Right);\n        }\n        return result;\n    }\n}\n\n// Usage\nvar tree = new BinaryTree();\nforeach (var val in new[] {50, 30, 70, 20, 40, 60, 80})\n    tree.Insert(val);\n\nConsole.WriteLine(\"Inorder:   \" + string.Join(\", \", tree.InorderTraversal()));\nConsole.WriteLine(\"Preorder:  \" + string.Join(\", \", tree.PreorderTraversal()));\nConsole.WriteLine(\"Postorder: \" + string.Join(\", \", tree.PostorderTraversal()));\nConsole.WriteLine(\"Level:     \" + string.Join(\", \", tree.LevelOrderTraversal()));"
}
